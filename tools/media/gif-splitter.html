<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIFÂàÜÂâ≤ - HTML Tools</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --bg-primary: #0a0a0f; --bg-secondary: #12121a; --bg-tertiary: #1a1a25; --text-primary: #fff; --text-secondary: #88a; --accent: #6366f1; --border: #2a2a3a; --success: #22c55e; }
        [data-theme="light"] { --bg-primary: #f8fafc; --bg-secondary: #fff; --bg-tertiary: #f1f5f9; --text-primary: #1e293b; --text-secondary: #64748b; --border: #e2e8f0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; }
        .header { background: linear-gradient(135deg, #ec4899, #db2777); padding: 2rem; text-align: center; }
        .header h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }
        .nav { display: flex; justify-content: space-between; max-width: 1200px; margin: 0 auto 1rem; }
        .back-link { color: rgba(255,255,255,0.9); text-decoration: none; }
        .theme-toggle { background: rgba(255,255,255,0.2); border: none; padding: 0.5rem 1rem; border-radius: 0.5rem; color: white; cursor: pointer; }
        .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem; margin-bottom: 1.5rem; }
        .drop-zone { border: 2px dashed var(--border); border-radius: 0.75rem; padding: 3rem; text-align: center; cursor: pointer; transition: all 0.2s; }
        .drop-zone:hover, .drop-zone.dragover { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
        .drop-zone input { display: none; }
        .preview-gif { max-width: 300px; max-height: 300px; margin: 1rem auto; display: block; border-radius: 0.5rem; }
        .info-bar { display: flex; justify-content: center; gap: 2rem; margin: 1rem 0; flex-wrap: wrap; }
        .info-item { text-align: center; }
        .info-item .value { font-size: 1.5rem; font-weight: 700; color: var(--accent); }
        .info-item .label { font-size: 0.85rem; color: var(--text-secondary); }
        .frames-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem; margin: 1.5rem 0; }
        .frame-card { background: var(--bg-tertiary); border-radius: 0.5rem; overflow: hidden; }
        .frame-card img { width: 100%; height: 120px; object-fit: contain; background: #000; }
        .frame-card .frame-info { padding: 0.75rem; display: flex; justify-content: space-between; align-items: center; }
        .frame-card .frame-num { font-weight: 600; }
        .frame-card .frame-delay { font-size: 0.85rem; color: var(--text-secondary); }
        .frame-card button { padding: 0.5rem 0.75rem; border: none; border-radius: 0.25rem; background: var(--accent); color: white; cursor: pointer; font-size: 0.85rem; }
        .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 1rem; transition: all 0.2s; }
        .btn-success { background: var(--success); color: white; }
        .btn-group { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
        .hidden { display: none; }
        .loading { text-align: center; padding: 2rem; color: var(--text-secondary); }
    </style>
</head>
<body>
    <div class="header">
        <div class="nav">
            <a href="../../index.html" class="back-link">‚Üê ËøîÂõûÈ¶ñÈ°µ</a>
            <button class="theme-toggle" onclick="toggleTheme()">üåì ‰∏ªÈ¢ò</button>
        </div>
        <h1>‚úÇÔ∏è GIFÂàÜÂâ≤</h1>
        <p>Â∞ÜGIFÂä®ÁîªÂàÜËß£‰∏∫ÂçïÁã¨ÁöÑÂ∏ßÂõæÁâá</p>
    </div>
    <div class="container">
        <div class="card">
            <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput" accept="image/gif" onchange="handleFile(this.files[0])">
                <div style="font-size: 3rem;">üé¨</div>
                <p>ÁÇπÂáªÈÄâÊã©GIFÊàñÊãñÊîæGIFÂà∞Ê≠§Â§Ñ</p>
            </div>
        </div>
        
        <div class="card hidden" id="resultSection">
            <img id="previewGif" class="preview-gif" alt="Preview">
            
            <div class="info-bar">
                <div class="info-item">
                    <div class="value" id="frameCount">0</div>
                    <div class="label">ÊÄªÂ∏ßÊï∞</div>
                </div>
                <div class="info-item">
                    <div class="value" id="gifSize">0x0</div>
                    <div class="label">Â∞∫ÂØ∏</div>
                </div>
                <div class="info-item">
                    <div class="value" id="totalDuration">0s</div>
                    <div class="label">ÊÄªÊó∂Èïø</div>
                </div>
            </div>
            
            <div class="loading hidden" id="loading">Ê≠£Âú®Ëß£ÊûêGIFÂ∏ß...</div>
            
            <div class="frames-grid" id="framesGrid"></div>
            
            <div class="btn-group">
                <button class="btn btn-success" onclick="downloadAll()">üíæ ‰∏ãËΩΩÂÖ®ÈÉ®Â∏ß</button>
            </div>
        </div>
    </div>
    <script>
        let extractedFrames = [];
        
        const dropZone = document.getElementById('dropZone');
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFile(e.dataTransfer.files[0]);
        });
        
        async function handleFile(file) {
            if (!file || file.type !== 'image/gif') {
                alert('ËØ∑ÈÄâÊã©GIFÊñá‰ª∂');
                return;
            }
            
            document.getElementById('resultSection').classList.remove('hidden');
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('framesGrid').innerHTML = '';
            extractedFrames = [];
            
            // Show preview
            const previewUrl = URL.createObjectURL(file);
            document.getElementById('previewGif').src = previewUrl;
            
            // Parse GIF
            const arrayBuffer = await file.arrayBuffer();
            const frames = await parseGif(new Uint8Array(arrayBuffer));
            
            document.getElementById('frameCount').textContent = frames.length;
            document.getElementById('loading').classList.add('hidden');
            
            let totalDuration = 0;
            const grid = document.getElementById('framesGrid');
            
            frames.forEach((frame, i) => {
                extractedFrames.push(frame);
                totalDuration += frame.delay;
                
                const card = document.createElement('div');
                card.className = 'frame-card';
                card.innerHTML = `
                    <img src="${frame.dataUrl}" alt="Frame ${i + 1}">
                    <div class="frame-info">
                        <div>
                            <div class="frame-num">Â∏ß ${i + 1}</div>
                            <div class="frame-delay">${frame.delay}ms</div>
                        </div>
                        <button onclick="downloadFrame(${i})">‰∏ãËΩΩ</button>
                    </div>
                `;
                grid.appendChild(card);
            });
            
            if (frames.length > 0) {
                document.getElementById('gifSize').textContent = `${frames[0].width}√ó${frames[0].height}`;
            }
            document.getElementById('totalDuration').textContent = (totalDuration / 1000).toFixed(2) + 's';
        }
        
        // Simple GIF parser
        async function parseGif(data) {
            const frames = [];
            
            // Create an image element to load the GIF
            const blob = new Blob([data], { type: 'image/gif' });
            const url = URL.createObjectURL(blob);
            
            const img = new Image();
            await new Promise(resolve => {
                img.onload = resolve;
                img.src = url;
            });
            
            const width = img.width;
            const height = img.height;
            
            // Use canvas to extract frames by playing through the GIF
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // For simplicity, we'll create a temporary image for each frame
            // This is a simplified approach - for more accurate parsing,
            // a full GIF decoder library would be needed
            
            // Try to extract frames using requestAnimationFrame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Basic frame extraction (simplified)
            // This creates one frame from the static image
            // For full GIF parsing, use a library like gifuct-js
            ctx.drawImage(img, 0, 0);
            
            // Since full GIF parsing requires complex decoding,
            // we'll use a workaround: create frames by assuming standard delay
            const estimatedFrameCount = Math.max(1, Math.min(50, Math.ceil(data.length / 10000)));
            const defaultDelay = 100;
            
            // Extract visible frames by drawing the GIF at different states
            // This is a simplified single-frame extraction
            frames.push({
                dataUrl: canvas.toDataURL('image/png'),
                delay: defaultDelay,
                width: width,
                height: height
            });
            
            // For proper multi-frame extraction, parse GIF binary data
            const gifFrames = parseGifFrames(data, width, height);
            if (gifFrames.length > 1) {
                frames.length = 0;
                frames.push(...gifFrames);
            }
            
            URL.revokeObjectURL(url);
            return frames;
        }
        
        function parseGifFrames(data, width, height) {
            const frames = [];
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            let pos = 0;
            
            // Check GIF header
            const header = String.fromCharCode(...data.slice(0, 6));
            if (!header.startsWith('GIF')) return frames;
            
            pos = 6;
            
            // Logical Screen Descriptor
            const lsdWidth = data[pos] | (data[pos + 1] << 8);
            const lsdHeight = data[pos + 2] | (data[pos + 3] << 8);
            const packed = data[pos + 4];
            const hasGct = (packed & 0x80) !== 0;
            const gctSize = 1 << ((packed & 0x07) + 1);
            pos += 7;
            
            // Global Color Table
            let gct = null;
            if (hasGct) {
                gct = [];
                for (let i = 0; i < gctSize; i++) {
                    gct.push([data[pos++], data[pos++], data[pos++]]);
                }
            }
            
            let delay = 100;
            let transparentIndex = -1;
            let disposalMethod = 0;
            
            // Previous frame data for disposal
            let previousImageData = null;
            
            while (pos < data.length) {
                const blockType = data[pos++];
                
                if (blockType === 0x21) { // Extension
                    const extType = data[pos++];
                    
                    if (extType === 0xF9) { // Graphics Control Extension
                        pos++; // Block size (always 4)
                        const gcPacked = data[pos++];
                        disposalMethod = (gcPacked >> 2) & 0x07;
                        const hasTransparency = (gcPacked & 0x01) !== 0;
                        delay = (data[pos] | (data[pos + 1] << 8)) * 10 || 100;
                        pos += 2;
                        transparentIndex = hasTransparency ? data[pos++] : -1;
                        pos++; // Block terminator
                    } else {
                        // Skip other extensions
                        while (data[pos] !== 0) {
                            pos += data[pos] + 1;
                        }
                        pos++;
                    }
                } else if (blockType === 0x2C) { // Image Descriptor
                    const left = data[pos] | (data[pos + 1] << 8);
                    const top = data[pos + 2] | (data[pos + 3] << 8);
                    const imgWidth = data[pos + 4] | (data[pos + 5] << 8);
                    const imgHeight = data[pos + 6] | (data[pos + 7] << 8);
                    const imgPacked = data[pos + 8];
                    pos += 9;
                    
                    const hasLct = (imgPacked & 0x80) !== 0;
                    const interlaced = (imgPacked & 0x40) !== 0;
                    const lctSize = 1 << ((imgPacked & 0x07) + 1);
                    
                    let lct = null;
                    if (hasLct) {
                        lct = [];
                        for (let i = 0; i < lctSize; i++) {
                            lct.push([data[pos++], data[pos++], data[pos++]]);
                        }
                    }
                    
                    const colorTable = lct || gct || [];
                    
                    // LZW Minimum Code Size
                    const minCodeSize = data[pos++];
                    
                    // Collect LZW data
                    let lzwData = [];
                    while (data[pos] !== 0) {
                        const subBlockSize = data[pos++];
                        for (let i = 0; i < subBlockSize; i++) {
                            lzwData.push(data[pos++]);
                        }
                    }
                    pos++;
                    
                    // Decode LZW
                    const pixels = decodeLZW(lzwData, minCodeSize, imgWidth * imgHeight);
                    
                    // Handle disposal
                    if (disposalMethod === 2) {
                        // Restore to background
                        ctx.clearRect(0, 0, width, height);
                    } else if (disposalMethod === 3 && previousImageData) {
                        // Restore to previous
                        ctx.putImageData(previousImageData, 0, 0);
                    }
                    
                    // Save current state if needed
                    if (disposalMethod === 3) {
                        previousImageData = ctx.getImageData(0, 0, width, height);
                    }
                    
                    // Draw pixels
                    const imageData = ctx.getImageData(0, 0, width, height);
                    let pixelIndex = 0;
                    
                    for (let y = 0; y < imgHeight; y++) {
                        for (let x = 0; x < imgWidth; x++) {
                            const colorIndex = pixels[pixelIndex++];
                            if (colorIndex !== transparentIndex && colorIndex < colorTable.length) {
                                const color = colorTable[colorIndex];
                                const offset = ((top + y) * width + (left + x)) * 4;
                                imageData.data[offset] = color[0];
                                imageData.data[offset + 1] = color[1];
                                imageData.data[offset + 2] = color[2];
                                imageData.data[offset + 3] = 255;
                            }
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    frames.push({
                        dataUrl: canvas.toDataURL('image/png'),
                        delay: delay,
                        width: width,
                        height: height
                    });
                    
                    transparentIndex = -1;
                    delay = 100;
                } else if (blockType === 0x3B) { // Trailer
                    break;
                } else {
                    // Unknown block, try to skip
                    break;
                }
            }
            
            return frames;
        }
        
        function decodeLZW(data, minCodeSize, pixelCount) {
            const clearCode = 1 << minCodeSize;
            const eoiCode = clearCode + 1;
            let codeSize = minCodeSize + 1;
            let codeMask = (1 << codeSize) - 1;
            
            let dictionary = [];
            for (let i = 0; i < clearCode; i++) {
                dictionary[i] = [i];
            }
            dictionary[clearCode] = [];
            dictionary[eoiCode] = null;
            
            let nextCode = eoiCode + 1;
            let oldCode = -1;
            
            const pixels = [];
            let bitBuffer = 0;
            let bitCount = 0;
            let dataIndex = 0;
            
            while (pixels.length < pixelCount && dataIndex < data.length) {
                while (bitCount < codeSize && dataIndex < data.length) {
                    bitBuffer |= data[dataIndex++] << bitCount;
                    bitCount += 8;
                }
                
                const code = bitBuffer & codeMask;
                bitBuffer >>= codeSize;
                bitCount -= codeSize;
                
                if (code === clearCode) {
                    codeSize = minCodeSize + 1;
                    codeMask = (1 << codeSize) - 1;
                    dictionary = [];
                    for (let i = 0; i < clearCode; i++) {
                        dictionary[i] = [i];
                    }
                    dictionary[clearCode] = [];
                    dictionary[eoiCode] = null;
                    nextCode = eoiCode + 1;
                    oldCode = -1;
                    continue;
                }
                
                if (code === eoiCode) break;
                
                let entry;
                if (code < dictionary.length && dictionary[code]) {
                    entry = dictionary[code];
                } else if (code === nextCode && oldCode >= 0) {
                    entry = [...dictionary[oldCode], dictionary[oldCode][0]];
                } else {
                    break;
                }
                
                pixels.push(...entry);
                
                if (oldCode >= 0 && nextCode < 4096) {
                    dictionary[nextCode++] = [...dictionary[oldCode], entry[0]];
                    if (nextCode > codeMask && codeSize < 12) {
                        codeSize++;
                        codeMask = (1 << codeSize) - 1;
                    }
                }
                
                oldCode = code;
            }
            
            return pixels;
        }
        
        window.downloadFrame = function(index) {
            const frame = extractedFrames[index];
            const link = document.createElement('a');
            link.download = `frame_${index + 1}.png`;
            link.href = frame.dataUrl;
            link.click();
        };
        
        window.downloadAll = function() {
            extractedFrames.forEach((frame, i) => {
                setTimeout(() => {
                    const link = document.createElement('a');
                    link.download = `frame_${i + 1}.png`;
                    link.href = frame.dataUrl;
                    link.click();
                }, i * 200);
            });
        };
        
        window.toggleTheme = function() {
            const t = document.body.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', t);
            localStorage.setItem('theme', t);
        };
        document.body.setAttribute('data-theme', localStorage.getItem('theme') || 'dark');
    </script>
</body>
</html>
