<!doctype html>
<html lang="zh-CN" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Ë¥™ÂêÉËõáÊ∏∏Êàè - WebUtils</title>
    <!-- SEO Meta Tags -->
    <meta name="description" content="Ë¥™ÂêÉËõáÊ∏∏Êàè - WebUtils" />
    <meta name="keywords" content="game-snake,game,tools,webutils" />
    <meta name="author" content="WebUtils" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://tools.realtime-ai.chat/tools/game/game-snake.html" />

    <!-- Open Graph -->
    <meta property="og:title" content="Ë¥™ÂêÉËõáÊ∏∏Êàè - WebUtils" />
    <meta property="og:description" content="Ë¥™ÂêÉËõáÊ∏∏Êàè - WebUtils" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://tools.realtime-ai.chat/tools/game/game-snake.html" />
    <meta property="og:site_name" content="WebUtils" />
    <meta property="og:locale" content="zh_CN" />
    <meta property="og:image" content="https://tools.realtime-ai.chat/social-preview.png" />
    <meta property="og:image:width" content="1280" />
    <meta property="og:image:height" content="640" />
    <meta property="og:image:type" content="image/png" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Ë¥™ÂêÉËõáÊ∏∏Êàè - WebUtils" />
    <meta name="twitter:description" content="Ë¥™ÂêÉËõáÊ∏∏Êàè - WebUtils" />
    <meta name="twitter:image" content="https://tools.realtime-ai.chat/social-preview.png" />

    <style>
      :root {
  /* Â≠ó‰ΩìÂèòÈáè */
  --font-sans: 'Space Grotesk', -apple-system, blinkmacsystemfont, 'Segoe UI', roboto, sans-serif;
  --font-mono: 'JetBrains Mono', 'Courier New', monospace;
        --color-bg-deep: #0a0a0f;
        --color-bg-surface: #12121a;
        --color-bg-card: #1a1a24;
        --bg-input: #0e0e14;
        --color-text-primary: #e8e8ed;
        --color-text-secondary: #8888a0;
        --color-text-muted: #55556a;
        --border-subtle: #2a2a3a;
        --border-strong: #3a3a4a;
        --color-accent-cyan: #00f5d4;
        --accent-green: #10b981;
        --accent-red: #f43f5e;
        --accent-yellow: #fbbf24;
        --color-accent-purple: #a855f7;
        --glow-cyan: rgb(0, 245, 212, 0.15);
        --glow-green: rgb(16, 185, 129, 0.15);
        --glow-red: rgb(244, 63, 94, 0.15);
        --radius-sm: 4px;
        --radius-md: 8px;
        --radius-lg: 12px;
      }

      [data-theme="light"] {
        --color-bg-deep: #fafafa;
        --color-bg-surface: #fff;
        --color-bg-card: #fff;
        --bg-input: #f5f5f5;
        --bg-hover: #f5f5f5;
        --color-text-primary: #1a1a1a;
        --color-text-secondary: #666;
        --color-text-muted: #999;
        --border-subtle: #e5e5e5;
        --border-strong: #d5d5d5;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg-primary: #0a0a0f;
        --bg-secondary: #1a1a2e;
        --bg-tertiary: #16213e;
        --color-text-primary: #fff;
        --color-text-secondary: #a0a0a0;
        --accent: #00d9ff;
        --accent-glow: rgba(0, 217, 255, 0.3);
        --snake-head: #0f8;
        --snake-body: #00cc6a;
        --food: #ff6b6b;
        --food-glow: rgba(255, 107, 107, 0.5);
        --grid-line: rgba(255, 255, 255, 0.05);
        --wall: #ff4757;
      }

      [data-theme="light"] {
        --bg-primary: #f0f4f8;
        --bg-secondary: #fff;
        --bg-tertiary: #e8eef4;
        --color-text-primary: #1a1a2e;
        --color-text-secondary: #666;
        --accent: #06c;
        --accent-glow: rgba(0, 102, 204, 0.2);
        --snake-head: #0a5;
        --snake-body: #00884a;
        --food: #e63946;
        --food-glow: rgba(230, 57, 70, 0.3);
        --grid-line: rgba(0, 0, 0, 0.08);
        --wall: #dc3545;
      }

      body {
        font-family: var(--font-sans);
        background: var(--bg-primary);
        color: var(--color-text-primary);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        transition: all 0.3s ease;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        max-width: 500px;
        margin-bottom: 20px;
      }

      .back-link {
        color: var(--color-text-secondary);
        text-decoration: none;
        font-size: 14px;
        transition: color 0.2s;
      }
      .back-link:hover {
        color: var(--accent);
      }

      h1 {
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .header-controls {
        display: flex;
        gap: 10px;
      }

      .icon-btn {
        background: var(--bg-secondary);
        border: 1px solid var(--bg-tertiary);
        color: var(--color-text-primary);
        width: 40px;
        height: 40px;
        border-radius: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        transition: all 0.3s ease;
      }

      .icon-btn:hover {
        background: var(--bg-tertiary);
        transform: scale(1.05);
      }

      .game-container {
        background: var(--bg-secondary);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 500px;
      }

      .score-board {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding: 15px;
        background: var(--bg-tertiary);
        border-radius: 12px;
      }

      .score-item {
        text-align: center;
      }

      .score-label {
        font-size: 0.75rem;
        color: var(--color-text-secondary);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
      }

      .score-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--accent);
      }

      .canvas-container {
        position: relative;
        width: 100%;
        aspect-ratio: 1;
        background: var(--bg-primary);
        border-radius: 12px;
        overflow: hidden;
      }

      #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .game-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 1;
        transition: opacity 0.3s ease;
        z-index: 10;
      }

      .game-overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .overlay-title {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 10px;
        color: var(--accent);
      }

      .overlay-score {
        font-size: 1.2rem;
        color: var(--color-text-secondary);
        margin-bottom: 20px;
      }

      .start-btn {
        background: linear-gradient(135deg, var(--snake-head), var(--snake-body));
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 1.1rem;
        font-weight: bold;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .start-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 20px var(--accent-glow);
      }

      .controls {
        margin-top: 20px;
      }

      .d-pad {
        display: grid;
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
        gap: 5px;
        justify-content: center;
      }

      .d-pad-btn {
        background: var(--bg-tertiary);
        border: 1px solid var(--bg-secondary);
        color: var(--color-text-primary);
        border-radius: 12px;
        font-size: 1.5rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      .d-pad-btn:active {
        background: var(--accent);
        transform: scale(0.95);
      }

      .d-pad-btn.empty {
        visibility: hidden;
      }

      .settings-panel {
        margin-top: 20px;
        padding: 15px;
        background: var(--bg-tertiary);
        border-radius: 12px;
      }

      .setting-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid var(--bg-secondary);
      }

      .setting-row:last-child {
        border-bottom: none;
      }

      .setting-label {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
      }

      .setting-control {
        display: flex;
        gap: 5px;
      }

      .speed-btn {
        background: var(--bg-secondary);
        border: 1px solid var(--bg-tertiary);
        color: var(--color-text-secondary);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.2s ease;
      }

      .speed-btn.active {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }

      .toggle-switch {
        position: relative;
        width: 50px;
        height: 26px;
        background: var(--bg-secondary);
        border-radius: 13px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .toggle-switch.active {
        background: var(--accent);
      }

      .toggle-switch::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .toggle-switch.active::after {
        left: 27px;
      }

      .instructions {
        margin-top: 20px;
        padding: 15px;
        background: var(--bg-tertiary);
        border-radius: 12px;
        font-size: 0.85rem;
        color: var(--color-text-secondary);
      }

      .instructions h3 {
        font-size: 0.9rem;
        color: var(--color-text-primary);
        margin-bottom: 10px;
      }

      .instructions ul {
        list-style: none;
        display: grid;
        gap: 5px;
      }

      .instructions li {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .key {
        background: var(--bg-secondary);
        padding: 4px 10px;
        border-radius: 5px;
        font-family: var(--font-mono);
        font-size: 0.8rem;
      }

      /* Animations */
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      .shake {
        animation: shake 0.3s ease;
      }

      /* Mobile optimizations */
      @media (max-width: 500px) {
        body {
          padding: 10px;
        }

        h1 {
          font-size: 1.2rem;
        }

        .game-container {
          padding: 15px;
          border-radius: 15px;
        }

        .d-pad {
          grid-template-columns: repeat(3, 55px);
          grid-template-rows: repeat(3, 55px);
        }

        .score-value {
          font-size: 1.2rem;
        }
      }

      /* Hide mobile controls on desktop */
      @media (min-width: 768px) {
        .controls {
          opacity: 0.3;
        }

        .controls:hover {
          opacity: 1;
        }
      }

      .breadcrumb {
        background: rgba(255, 255, 255, 0.95);
        padding: 8px 15px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        font-size: 0.85rem;
      }
      .breadcrumb a {
        color: #667eea;
        text-decoration: none;
      }
      .breadcrumb a:hover {
        text-decoration: underline;
      }
      .breadcrumb span {
        color: #999;
        margin: 0 5px;
      }
    </style>
    <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
  <body>
    <nav class="breadcrumb">
      <a href="../../index.html">È¶ñÈ°µ</a>
      <span>‚Ä∫</span>
      Ë¥™ÂêÉËõá
    </nav>
    <div class="header">
      <a href="../../index.html" class="back-link">‚Üê ËøîÂõû</a>
      <h1>üêç Ë¥™ÂêÉËõá</h1>
      <div class="header-controls">
        <button class="icon-btn" id="soundBtn" title="Èü≥Êïà">üîä</button>
        <button class="icon-btn" id="themeBtn" title="ÂàáÊç¢‰∏ªÈ¢ò">üåô</button>
      </div>
    </div>

    <div class="game-container">
      <div class="score-board">
        <div class="score-item">
          <div class="score-label">ÂæóÂàÜ</div>
          <div class="score-value" id="score">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ÈïøÂ∫¶</div>
          <div class="score-value" id="length">3</div>
        </div>
        <div class="score-item">
          <div class="score-label">ÊúÄÈ´òÂàÜ</div>
          <div class="score-value" id="bestScore">0</div>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div class="game-overlay" id="overlay">
          <div class="overlay-title" id="overlayTitle">Ë¥™ÂêÉËõá</div>
          <div class="overlay-score" id="overlayScore">‰ΩøÁî®ÊñπÂêëÈîÆÊàñÊªëÂä®ÊéßÂà∂</div>
          <button class="start-btn" id="startBtn">ÂºÄÂßãÊ∏∏Êàè</button>
        </div>
      </div>

      <div class="controls">
        <div class="d-pad">
          <div class="d-pad-btn empty"></div>
          <button class="d-pad-btn" data-dir="up">‚Üë</button>
          <div class="d-pad-btn empty"></div>
          <button class="d-pad-btn" data-dir="left">‚Üê</button>
          <div class="d-pad-btn empty"></div>
          <button class="d-pad-btn" data-dir="right">‚Üí</button>
          <div class="d-pad-btn empty"></div>
          <button class="d-pad-btn" data-dir="down">‚Üì</button>
          <div class="d-pad-btn empty"></div>
        </div>
      </div>

      <div class="settings-panel">
        <div class="setting-row">
          <span class="setting-label">Ê∏∏ÊàèÈÄüÂ∫¶</span>
          <div class="setting-control">
            <button class="speed-btn" data-speed="slow">ÊÖ¢</button>
            <button class="speed-btn active" data-speed="normal">‰∏≠</button>
            <button class="speed-btn" data-speed="fast">Âø´</button>
          </div>
        </div>
        <div class="setting-row">
          <span class="setting-label">Á©øÂ¢ôÊ®°Âºè</span>
          <div class="toggle-switch" id="wallToggle"></div>
        </div>
      </div>

      <div class="instructions">
        <h3>Êìç‰ΩúËØ¥Êòé</h3>
        <ul>
          <li>
            <span class="key">‚Üë‚Üì‚Üê‚Üí</span>
            Êàñ
            <span class="key">WASD</span>
            ÊéßÂà∂ÊñπÂêë
          </li>
          <li>
            <span class="key">Á©∫Ê†º</span>
            ÊöÇÂÅú/ÁªßÁª≠
          </li>
          <li>ÁßªÂä®Á´ØÂèØÊªëÂä®Â±èÂπïÊàñ‰ΩøÁî®ÊñπÂêëÊåâÈíÆ</li>
        </ul>
      </div>
    </div>

    <script>
      // Audio Context for sound effects
      let audioCtx = null;
      let soundEnabled = true;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
      }

      function playSound(type) {
        if (!soundEnabled || !audioCtx) return;

        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        switch (type) {
          case "eat":
            oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
            oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.05); // E5
            oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.1); // G5
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gainNode.gain.exponentialDecayTo(0.01, audioCtx.currentTime + 0.15);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
            break;
          case "die":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialDecayTo(0.01, audioCtx.currentTime + 0.3);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.3);
            break;
          case "turn":
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.exponentialDecayTo(0.01, audioCtx.currentTime + 0.05);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.05);
            break;
        }
      }

      // Polyfill for exponentialDecayTo
      GainNode.prototype.exponentialDecayTo = function (value, time) {
        this.gain.exponentialRampToValueAtTime(Math.max(value, 0.0001), time);
      };

      // Game State
      const GRID_SIZE = 20;
      let canvas, ctx;
      let cellSize;
      let snake = [];
      let food = { x: 0, y: 0 };
      let direction = { x: 1, y: 0 };
      let nextDirection = { x: 1, y: 0 };
      let score = 0;
      let bestScore = 0;
      let gameLoop = null;
      let gameState = "idle"; // idle, playing, paused, gameover
      let wallMode = false; // true = can pass through walls

      const SPEEDS = {
        slow: 150,
        normal: 100,
        fast: 60
      };
      let currentSpeed = "normal";

      // DOM Elements
      const scoreEl = document.getElementById("score");
      const lengthEl = document.getElementById("length");
      const bestScoreEl = document.getElementById("bestScore");
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlayScore = document.getElementById("overlayScore");
      const startBtn = document.getElementById("startBtn");
      const soundBtn = document.getElementById("soundBtn");
      const themeBtn = document.getElementById("themeBtn");
      const wallToggle = document.getElementById("wallToggle");
      const speedBtns = document.querySelectorAll(".speed-btn");
      const dPadBtns = document.querySelectorAll(".d-pad-btn[data-dir]");

      // Initialize
      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        // Set canvas size
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        // Load settings
        loadSettings();

        // Event listeners
        startBtn.addEventListener("click", startGame);
        soundBtn.addEventListener("click", toggleSound);
        themeBtn.addEventListener("click", toggleTheme);
        wallToggle.addEventListener("click", toggleWall);

        speedBtns.forEach((btn) => {
          btn.addEventListener("click", () => setSpeed(btn.dataset.speed));
        });

        dPadBtns.forEach((btn) => {
          btn.addEventListener("click", () => handleDirection(btn.dataset.dir));
          btn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            handleDirection(btn.dataset.dir);
          });
        });

        // Keyboard controls
        document.addEventListener("keydown", handleKeyDown);

        // Touch/Swipe controls
        setupTouchControls();

        // Draw initial state
        drawGame();
      }

      function resizeCanvas() {
        const container = canvas.parentElement;
        const size = Math.min(container.clientWidth, container.clientHeight);
        canvas.width = size * window.devicePixelRatio;
        canvas.height = size * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        cellSize = size / GRID_SIZE;

        if (gameState !== "idle") {
          drawGame();
        }
      }

      function loadSettings() {
        bestScore = parseInt(localStorage.getItem("snake_bestScore") || "0");
        bestScoreEl.textContent = bestScore;

        soundEnabled = localStorage.getItem("snake_sound") !== "false";
        soundBtn.textContent = soundEnabled ? "üîä" : "üîá";

        const theme = localStorage.getItem("snake_theme") || "dark";
        document.documentElement.setAttribute("data-theme", theme);
        themeBtn.textContent = theme === "dark" ? "üåô" : "‚òÄÔ∏è";

        wallMode = localStorage.getItem("snake_wallMode") === "true";
        if (wallMode) wallToggle.classList.add("active");

        currentSpeed = localStorage.getItem("snake_speed") || "normal";
        speedBtns.forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.speed === currentSpeed);
        });
      }

      function saveSettings() {
        localStorage.setItem("snake_bestScore", bestScore);
        localStorage.setItem("snake_sound", soundEnabled);
        localStorage.setItem("snake_theme", document.documentElement.getAttribute("data-theme"));
        localStorage.setItem("snake_wallMode", wallMode);
        localStorage.setItem("snake_speed", currentSpeed);
      }

      function toggleSound() {
        initAudio();
        soundEnabled = !soundEnabled;
        soundBtn.textContent = soundEnabled ? "üîä" : "üîá";
        saveSettings();
      }

      function toggleTheme() {
        const current = document.documentElement.getAttribute("data-theme");
        const next = current === "dark" ? "light" : "dark";
        document.documentElement.setAttribute("data-theme", next);
        themeBtn.textContent = next === "dark" ? "üåô" : "‚òÄÔ∏è";
        saveSettings();
        drawGame();
      }

      function toggleWall() {
        wallMode = !wallMode;
        wallToggle.classList.toggle("active", wallMode);
        saveSettings();
      }

      function setSpeed(speed) {
        currentSpeed = speed;
        speedBtns.forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.speed === speed);
        });
        saveSettings();

        // Update game loop if playing
        if (gameState === "playing") {
          clearInterval(gameLoop);
          gameLoop = setInterval(gameStep, SPEEDS[currentSpeed]);
        }
      }

      function startGame() {
        initAudio();

        // Reset game state
        snake = [
          { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) },
          { x: Math.floor(GRID_SIZE / 2) - 1, y: Math.floor(GRID_SIZE / 2) },
          { x: Math.floor(GRID_SIZE / 2) - 2, y: Math.floor(GRID_SIZE / 2) }
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
        score = 0;
        updateScore();

        spawnFood();

        gameState = "playing";
        overlay.classList.add("hidden");

        // Start game loop
        if (gameLoop) clearInterval(gameLoop);
        gameLoop = setInterval(gameStep, SPEEDS[currentSpeed]);
      }

      function gameStep() {
        if (gameState !== "playing") return;

        // Apply direction change
        direction = { ...nextDirection };

        // Calculate new head position
        let newHead = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y
        };

        // Handle wall collision
        if (wallMode) {
          // Wrap around
          if (newHead.x < 0) newHead.x = GRID_SIZE - 1;
          if (newHead.x >= GRID_SIZE) newHead.x = 0;
          if (newHead.y < 0) newHead.y = GRID_SIZE - 1;
          if (newHead.y >= GRID_SIZE) newHead.y = 0;
        } else {
          // Game over on wall hit
          if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
            gameOver();
            return;
          }
        }

        // Check self collision
        for (let i = 0; i < snake.length; i++) {
          if (snake[i].x === newHead.x && snake[i].y === newHead.y) {
            gameOver();
            return;
          }
        }

        // Add new head
        snake.unshift(newHead);

        // Check food collision
        if (newHead.x === food.x && newHead.y === food.y) {
          score += 10;
          updateScore();
          playSound("eat");
          spawnFood();
        } else {
          // Remove tail if not eating
          snake.pop();
        }

        drawGame();
      }

      function spawnFood() {
        let valid = false;
        while (!valid) {
          food = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE)
          };
          valid = true;
          for (let segment of snake) {
            if (segment.x === food.x && segment.y === food.y) {
              valid = false;
              break;
            }
          }
        }
      }

      function gameOver() {
        gameState = "gameover";
        clearInterval(gameLoop);
        playSound("die");

        // Update best score
        if (score > bestScore) {
          bestScore = score;
          bestScoreEl.textContent = bestScore;
          saveSettings();
        }

        // Shake effect
        canvas.parentElement.classList.add("shake");
        setTimeout(() => canvas.parentElement.classList.remove("shake"), 300);

        // Show overlay
        overlayTitle.textContent = "Ê∏∏ÊàèÁªìÊùü";
        overlayScore.textContent = `ÂæóÂàÜ: ${score}`;
        startBtn.textContent = "ÂÜçÊù•‰∏ÄÂ±Ä";
        overlay.classList.remove("hidden");
      }

      function updateScore() {
        scoreEl.textContent = score;
        lengthEl.textContent = snake.length;
      }

      function drawGame() {
        const size = canvas.width / window.devicePixelRatio;
        ctx.clearRect(0, 0, size, size);

        // Draw grid
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue(
          "--grid-line"
        );
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
          ctx.beginPath();
          ctx.moveTo(i * cellSize, 0);
          ctx.lineTo(i * cellSize, size);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * cellSize);
          ctx.lineTo(size, i * cellSize);
          ctx.stroke();
        }

        // Draw food with glow
        const foodColor = getComputedStyle(document.documentElement).getPropertyValue("--food");
        const foodGlow = getComputedStyle(document.documentElement).getPropertyValue("--food-glow");
        ctx.shadowColor = foodGlow;
        ctx.shadowBlur = 15;
        ctx.fillStyle = foodColor;
        ctx.beginPath();
        ctx.arc(
          food.x * cellSize + cellSize / 2,
          food.y * cellSize + cellSize / 2,
          cellSize / 2.5,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw snake
        const headColor = getComputedStyle(document.documentElement).getPropertyValue(
          "--snake-head"
        );
        const bodyColor = getComputedStyle(document.documentElement).getPropertyValue(
          "--snake-body"
        );

        snake.forEach((segment, index) => {
          const isHead = index === 0;
          ctx.fillStyle = isHead ? headColor : bodyColor;

          // Rounded rectangle for each segment
          const padding = 2;
          const x = segment.x * cellSize + padding;
          const y = segment.y * cellSize + padding;
          const w = cellSize - padding * 2;
          const h = cellSize - padding * 2;
          const radius = isHead ? w / 3 : w / 4;

          ctx.beginPath();
          ctx.roundRect(x, y, w, h, radius);
          ctx.fill();

          // Draw eyes on head
          if (isHead) {
            ctx.fillStyle = "#fff";
            const eyeSize = cellSize / 8;
            const eyeOffset = cellSize / 4;

            let eye1x, eye1y, eye2x, eye2y;

            if (direction.x === 1) {
              // Right
              eye1x = x + w - eyeOffset;
              eye1y = y + eyeOffset;
              eye2x = x + w - eyeOffset;
              eye2y = y + h - eyeOffset;
            } else if (direction.x === -1) {
              // Left
              eye1x = x + eyeOffset;
              eye1y = y + eyeOffset;
              eye2x = x + eyeOffset;
              eye2y = y + h - eyeOffset;
            } else if (direction.y === -1) {
              // Up
              eye1x = x + eyeOffset;
              eye1y = y + eyeOffset;
              eye2x = x + w - eyeOffset;
              eye2y = y + eyeOffset;
            } else {
              // Down
              eye1x = x + eyeOffset;
              eye1y = y + h - eyeOffset;
              eye2x = x + w - eyeOffset;
              eye2y = y + h - eyeOffset;
            }

            ctx.beginPath();
            ctx.arc(eye1x, eye1y, eyeSize, 0, Math.PI * 2);
            ctx.arc(eye2x, eye2y, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          }
        });
      }

      function handleDirection(dir) {
        const dirMap = {
          up: { x: 0, y: -1 },
          down: { x: 0, y: 1 },
          left: { x: -1, y: 0 },
          right: { x: 1, y: 0 }
        };

        const newDir = dirMap[dir];
        if (!newDir) return;

        // Prevent 180 degree turn
        if (newDir.x !== -direction.x || newDir.y !== -direction.y) {
          nextDirection = newDir;
          playSound("turn");
        }
      }

      function handleKeyDown(e) {
        // Start game on any key if idle
        if (gameState === "idle" && e.code !== "Escape") {
          startGame();
          return;
        }

        // Pause/Resume
        if (e.code === "Space") {
          e.preventDefault();
          if (gameState === "playing") {
            gameState = "paused";
            clearInterval(gameLoop);
            overlayTitle.textContent = "Â∑≤ÊöÇÂÅú";
            overlayScore.textContent = "ÊåâÁ©∫Ê†ºÁªßÁª≠";
            startBtn.textContent = "ÁªßÁª≠Ê∏∏Êàè";
            overlay.classList.remove("hidden");
          } else if (gameState === "paused") {
            gameState = "playing";
            overlay.classList.add("hidden");
            gameLoop = setInterval(gameStep, SPEEDS[currentSpeed]);
          }
          return;
        }

        // Direction controls
        const keyMap = {
          ArrowUp: "up",
          KeyW: "up",
          ArrowDown: "down",
          KeyS: "down",
          ArrowLeft: "left",
          KeyA: "left",
          ArrowRight: "right",
          KeyD: "right"
        };

        if (keyMap[e.code]) {
          e.preventDefault();
          handleDirection(keyMap[e.code]);
        }
      }

      function setupTouchControls() {
        let touchStartX = 0;
        let touchStartY = 0;
        const minSwipe = 30;

        canvas.addEventListener(
          "touchstart",
          (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          },
          { passive: true }
        );

        canvas.addEventListener(
          "touchend",
          (e) => {
            if (gameState !== "playing") return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) < minSwipe && Math.abs(deltaY) < minSwipe) return;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
              handleDirection(deltaX > 0 ? "right" : "left");
            } else {
              handleDirection(deltaY > 0 ? "down" : "up");
            }
          },
          { passive: true }
        );
      }

      // Polyfill for roundRect
      if (!ctx?.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
        };
      }

      // Start
      init();
    </script>
  </body>
</html>
