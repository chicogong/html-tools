<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹ - WebUtils</title>
    <!-- SEO Meta Tags -->
    <meta name="description" content="å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹ - WebUtils" />
    <meta name="keywords" content="image-pixelate,media,tools,webutils" />
    <meta name="author" content="WebUtils" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://tools.realtime-ai.chat/tools/media/image-pixelate.html" />

    <!-- Open Graph -->
    <meta property="og:title" content="å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹ - WebUtils" />
    <meta property="og:description" content="å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹ - WebUtils" />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://tools.realtime-ai.chat/tools/media/image-pixelate.html"
    />
    <meta property="og:site_name" content="WebUtils" />
    <meta property="og:locale" content="zh_CN" />
    <meta property="og:image" content="https://tools.realtime-ai.chat/social-preview.png" />
    <meta property="og:image:width" content="1280" />
    <meta property="og:image:height" content="640" />
    <meta property="og:image:type" content="image/png" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹ - WebUtils" />
    <meta name="twitter:description" content="å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹ - WebUtils" />
    <meta name="twitter:image" content="https://tools.realtime-ai.chat/social-preview.png" />

    <style>
      :root {
        --bg-deep: #0a0a0f;
        --bg-surface: #12121a;
        --bg-card: #1a1a24;
        --bg-input: #0e0e14;
        --text-primary: #e8e8ed;
        --text-secondary: #8888a0;
        --text-muted: #55556a;
        --border-subtle: #2a2a3a;
        --border-strong: #3a3a4a;
        --accent-cyan: #00f5d4;
        --accent-green: #10b981;
        --accent-red: #f43f5e;
        --accent-yellow: #fbbf24;
        --accent-purple: #a855f7;
        --glow-cyan: rgb(0, 245, 212, 0.15);
        --glow-green: rgb(16, 185, 129, 0.15);
        --glow-red: rgb(244, 63, 94, 0.15);
        --radius-sm: 4px;
        --radius-md: 8px;
        --radius-lg: 12px;
      }

      [data-theme="light"] {
        --bg-deep: #fafafa;
        --bg-surface: #fff;
        --bg-card: #fff;
        --bg-input: #f5f5f5;
        --bg-hover: #f5f5f5;
        --text-primary: #1a1a1a;
        --text-secondary: #666;
        --text-muted: #999;
        --border-subtle: #e5e5e5;
        --border-strong: #d5d5d5;
      }

      :root {
        --bg-color: #1a1a2e;
        --card-bg: #16213e;
        --text-color: #e0e0e0;
        --primary-color: #0f3460;
        --accent-color: #e94560;
        --border-color: #0f3460;
        --input-bg: #1a1a2e;
        --success-color: #4ade80;
      }

      [data-theme="light"] {
        --bg-color: #f0f4f8;
        --card-bg: #fff;
        --text-color: #1a1a2e;
        --primary-color: #e0e7ff;
        --accent-color: #e94560;
        --border-color: #c7d2fe;
        --input-bg: #f8fafc;
        --success-color: #22c55e;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        font-size: 16px;
        line-height: 1.6;
        background: var(--bg-color);
        color: var(--text-color);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
        position: relative;
      }

      .header h1 {
        font-size: 2rem;
        margin-bottom: 10px;
        background: linear-gradient(135deg, var(--accent-color), #a855f7);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .theme-toggle {
        position: absolute;
        right: 0;
        top: 0;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .theme-toggle:hover {
        background: var(--primary-color);
      }

      .back-link {
        position: absolute;
        left: 0;
        top: 0;
        color: var(--accent-color);
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 14px;
      }

      .back-link:hover {
        text-decoration: underline;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 300px 1fr;
        gap: 20px;
      }

      @media (max-width: 900px) {
        .main-grid {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid var(--border-color);
      }

      .panel-title {
        font-size: 1.1rem;
        margin-bottom: 15px;
        color: var(--accent-color);
      }

      .upload-zone {
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        padding: 30px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 20px;
      }

      .upload-zone:hover,
      .upload-zone.dragover {
        border-color: var(--accent-color);
        background: var(--primary-color);
      }

      .upload-zone input {
        display: none;
      }

      .upload-icon {
        font-size: 40px;
        margin-bottom: 10px;
      }

      .control-group {
        margin-bottom: 20px;
      }

      .control-label {
        display: block;
        margin-bottom: 8px;
        font-size: 0.9rem;
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .control-row input[type="range"] {
        flex: 1;
      }

      .control-value {
        min-width: 50px;
        text-align: right;
        font-family: Consolas, monospace;
        font-size: 14px;
      }

      input[type="range"] {
        -webkit-appearance: none;
        height: 6px;
        background: var(--border-color);
        border-radius: 3px;
        width: 100%;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        background: var(--accent-color);
        border-radius: 50%;
        cursor: pointer;
      }

      .effect-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-bottom: 20px;
      }

      .effect-btn {
        padding: 12px;
        background: var(--input-bg);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        transition: all 0.3s ease;
        color: var(--text-color);
      }

      .effect-btn:hover {
        border-color: var(--accent-color);
      }

      .effect-btn.active {
        border-color: var(--accent-color);
        background: var(--primary-color);
      }

      .effect-name {
        font-size: 13px;
      }

      .btn {
        padding: 10px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        width: 100%;
        justify-content: center;
      }

      .btn-primary {
        background: var(--accent-color);
        color: white;
      }

      .btn-primary:hover {
        opacity: 0.9;
      }

      .btn-secondary {
        background: var(--primary-color);
        color: var(--text-color);
        border: 1px solid var(--border-color);
      }

      .btn-secondary:hover {
        background: var(--border-color);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .buttons-stack {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .preview-container {
        position: relative;
        background:
          linear-gradient(45deg, #ccc 25%, transparent 25%),
          linear-gradient(-45deg, #ccc 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #ccc 75%),
          linear-gradient(-45deg, transparent 75%, #ccc 75%);
        background-size: 20px 20px;
        background-position:
          0 0,
          0 10px,
          10px -10px,
          -10px 0;
        border-radius: 8px;
        min-height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .preview-placeholder {
        text-align: center;
        opacity: 0.5;
      }

      .preview-placeholder .icon {
        font-size: 64px;
        margin-bottom: 10px;
      }

      #previewCanvas {
        max-width: 100%;
        max-height: 500px;
        display: none;
      }

      .image-info {
        display: flex;
        justify-content: space-between;
        padding: 10px;
        background: var(--primary-color);
        border-radius: 8px;
        margin-top: 15px;
        font-size: 13px;
      }

      .region-mode {
        background: var(--input-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 15px;
      }

      .region-mode label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 14px;
      }

      .region-mode input[type="checkbox"] {
        width: 18px;
        height: 18px;
      }

      .region-hint {
        font-size: 12px;
        opacity: 0.7;
        margin-top: 8px;
      }

      .brush-size {
        margin-top: 10px;
      }

      .hidden {
        display: none !important;
      }

      .breadcrumb {
        background: rgba(255, 255, 255, 0.95);
        padding: 8px 15px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        font-size: 0.85rem;
      }
      .breadcrumb a {
        color: #667eea;
        text-decoration: none;
      }
      .breadcrumb a:hover {
        text-decoration: underline;
      }
      .breadcrumb span {
        color: #999;
        margin: 0 5px;
      }
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        padding: 0;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <nav class="breadcrumb">
      <a href="../../index.html">é¦–é¡µ</a>
      <span>â€º</span>
      å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹
    </nav>
    <div class="container">
      <div class="header">
        <h1>ğŸ¨ å›¾ç‰‡åƒç´ åŒ–/é©¬èµ›å…‹</h1>
        <p>ä¸ºå›¾ç‰‡æ·»åŠ åƒç´ åŒ–æˆ–é©¬èµ›å…‹æ•ˆæœ</p>
        <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ“ åˆ‡æ¢ä¸»é¢˜</button>
      </div>

      <div class="main-grid">
        <div class="panel">
          <div class="panel-title">ğŸ“¤ ä¸Šä¼ å›¾ç‰‡</div>
          <div class="upload-zone" id="uploadZone">
            <input type="file" id="fileInput" accept="image/*" />
            <div class="upload-icon">ğŸ“</div>
            <p>æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</p>
            <p style="font-size: 12px; opacity: 0.7">æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
          </div>

          <div class="panel-title">âœ¨ æ•ˆæœç±»å‹</div>
          <div class="effect-grid">
            <div class="effect-btn active" data-effect="pixelate" onclick="setEffect('pixelate')">
              <div style="font-size: 24px; margin-bottom: 5px">â–¦</div>
              <div class="effect-name">åƒç´ åŒ–</div>
            </div>
            <div class="effect-btn" data-effect="mosaic" onclick="setEffect('mosaic')">
              <div style="font-size: 24px; margin-bottom: 5px">â–§</div>
              <div class="effect-name">é©¬èµ›å…‹</div>
            </div>
            <div class="effect-btn" data-effect="blur" onclick="setEffect('blur')">
              <div style="font-size: 24px; margin-bottom: 5px">â—</div>
              <div class="effect-name">æ¨¡ç³Š</div>
            </div>
            <div class="effect-btn" data-effect="oil" onclick="setEffect('oil')">
              <div style="font-size: 24px; margin-bottom: 5px">ğŸ¨</div>
              <div class="effect-name">æ²¹ç”»</div>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">æ•ˆæœå¼ºåº¦</label>
            <div class="control-row">
              <input
                type="range"
                id="intensity"
                min="2"
                max="50"
                value="10"
                oninput="updatePreview()"
              />
              <span class="control-value" id="intensityVal">10</span>
            </div>
          </div>

          <div class="region-mode">
            <label>
              <input type="checkbox" id="regionMode" onchange="toggleRegionMode()" />
              å±€éƒ¨å¤„ç†æ¨¡å¼
            </label>
            <div class="region-hint">å‹¾é€‰åå¯ç”¨é¼ æ ‡æ¶‚æŠ¹éœ€è¦å¤„ç†çš„åŒºåŸŸ</div>
            <div class="brush-size hidden" id="brushSizeControl">
              <label class="control-label">ç”»ç¬”å¤§å°</label>
              <div class="control-row">
                <input type="range" id="brushSize" min="10" max="100" value="30" />
                <span class="control-value" id="brushSizeVal">30</span>
              </div>
            </div>
          </div>

          <div class="buttons-stack">
            <button class="btn btn-primary" id="applyBtn" onclick="applyEffect()" disabled>
              âœ¨ åº”ç”¨æ•ˆæœ
            </button>
            <button class="btn btn-secondary" id="resetBtn" onclick="resetImage()" disabled>
              ğŸ”„ é‡ç½®å›¾ç‰‡
            </button>
            <button class="btn btn-secondary" id="downloadBtn" onclick="downloadImage()" disabled>
              ğŸ’¾ ä¸‹è½½å›¾ç‰‡
            </button>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">ğŸ‘ï¸ é¢„è§ˆ</div>
          <div class="preview-container" id="previewContainer">
            <div class="preview-placeholder" id="placeholder">
              <div class="icon">ğŸ–¼ï¸</div>
              <p>ä¸Šä¼ å›¾ç‰‡å¼€å§‹å¤„ç†</p>
            </div>
            <canvas id="previewCanvas"></canvas>
          </div>
          <div class="image-info hidden" id="imageInfo">
            <span id="imageDimensions">å°ºå¯¸: -</span>
            <span id="imageSize">å¤§å°: -</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      let originalImage = null;
      let currentImage = null;
      let currentEffect = "pixelate";
      let isRegionMode = false;
      let isDrawing = false;
      let mask = null;

      const canvas = document.getElementById("previewCanvas");
      const ctx = canvas.getContext("2d");

      // Theme toggle
      window.toggleTheme = function () {
        const body = document.body;
        const currentTheme = body.getAttribute("data-theme");
        const newTheme = currentTheme === "light" ? "dark" : "light";
        body.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);
      };

      (function () {
        const savedTheme = localStorage.getItem("theme") || "dark";
        if (savedTheme === "light") {
          document.body.setAttribute("data-theme", "light");
        }
      })();

      // File upload
      const uploadZone = document.getElementById("uploadZone");
      const fileInput = document.getElementById("fileInput");

      uploadZone.addEventListener("click", () => fileInput.click());
      uploadZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () => {
        uploadZone.classList.remove("dragover");
      });
      uploadZone.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadZone.classList.remove("dragover");
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          loadImage(file);
        }
      });
      fileInput.addEventListener("change", (e) => {
        if (e.target.files[0]) {
          loadImage(e.target.files[0]);
        }
      });

      window.loadImage = function (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            originalImage = img;
            currentImage = img;

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            canvas.style.display = "block";
            document.getElementById("placeholder").style.display = "none";

            document.getElementById("applyBtn").disabled = false;
            document.getElementById("resetBtn").disabled = false;
            document.getElementById("downloadBtn").disabled = false;

            document.getElementById("imageInfo").classList.remove("hidden");
            document.getElementById("imageDimensions").textContent =
              `å°ºå¯¸: ${img.width} Ã— ${img.height}`;
            document.getElementById("imageSize").textContent =
              `å¤§å°: ${(file.size / 1024).toFixed(1)} KB`;

            // Initialize mask
            mask = new Uint8Array(img.width * img.height);
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      };

      window.setEffect = function (effect) {
        currentEffect = effect;
        document.querySelectorAll(".effect-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.effect === effect);
        });
      };

      window.toggleRegionMode = function () {
        isRegionMode = document.getElementById("regionMode").checked;
        document.getElementById("brushSizeControl").classList.toggle("hidden", !isRegionMode);

        if (isRegionMode) {
          canvas.style.cursor = "crosshair";
          // Reset mask
          if (mask) mask.fill(0);
        } else {
          canvas.style.cursor = "default";
        }
      };

      // Brush drawing for region mode
      canvas.addEventListener("mousedown", (e) => {
        if (!isRegionMode || !originalImage) return;
        isDrawing = true;
        draw(e);
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!isDrawing || !isRegionMode) return;
        draw(e);
      });

      canvas.addEventListener("mouseup", () => (isDrawing = false));
      canvas.addEventListener("mouseleave", () => (isDrawing = false));

      function draw(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);
        const brushSize = parseInt(document.getElementById("brushSize").value);

        // Update mask
        for (let dy = -brushSize; dy <= brushSize; dy++) {
          for (let dx = -brushSize; dx <= brushSize; dx++) {
            if (dx * dx + dy * dy <= brushSize * brushSize) {
              const px = x + dx;
              const py = y + dy;
              if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                mask[py * canvas.width + px] = 1;
              }
            }
          }
        }

        // Show brush area visually
        ctx.fillStyle = "rgba(233, 69, 96, 0.3)";
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.fill();
      }

      document.getElementById("brushSize").addEventListener("input", (e) => {
        document.getElementById("brushSizeVal").textContent = e.target.value;
      });

      document.getElementById("intensity").addEventListener("input", (e) => {
        document.getElementById("intensityVal").textContent = e.target.value;
      });

      window.applyEffect = function () {
        if (!originalImage) return;

        const intensity = parseInt(document.getElementById("intensity").value);

        // Redraw original
        ctx.drawImage(originalImage, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        switch (currentEffect) {
          case "pixelate":
            pixelate(data, canvas.width, canvas.height, intensity);
            break;
          case "mosaic":
            mosaic(data, canvas.width, canvas.height, intensity);
            break;
          case "blur":
            blur(data, canvas.width, canvas.height, intensity);
            break;
          case "oil":
            oilPaint(data, canvas.width, canvas.height, Math.min(intensity, 10));
            break;
        }

        ctx.putImageData(imageData, 0, 0);
      };

      function pixelate(data, width, height, blockSize) {
        for (let y = 0; y < height; y += blockSize) {
          for (let x = 0; x < width; x += blockSize) {
            // Check if this block should be processed (region mode)
            if (isRegionMode) {
              let shouldProcess = false;
              for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
                for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                  if (mask[(y + dy) * width + (x + dx)]) {
                    shouldProcess = true;
                    break;
                  }
                }
                if (shouldProcess) break;
              }
              if (!shouldProcess) continue;
            }

            // Get average color
            let r = 0,
              g = 0,
              b = 0,
              count = 0;
            for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
              for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                const idx = ((y + dy) * width + (x + dx)) * 4;
                r += data[idx];
                g += data[idx + 1];
                b += data[idx + 2];
                count++;
              }
            }
            r = Math.floor(r / count);
            g = Math.floor(g / count);
            b = Math.floor(b / count);

            // Fill block
            for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
              for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                const idx = ((y + dy) * width + (x + dx)) * 4;
                data[idx] = r;
                data[idx + 1] = g;
                data[idx + 2] = b;
              }
            }
          }
        }
      }

      function mosaic(data, width, height, blockSize) {
        // Similar to pixelate but with slight random variation
        for (let y = 0; y < height; y += blockSize) {
          for (let x = 0; x < width; x += blockSize) {
            if (isRegionMode) {
              let shouldProcess = false;
              for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
                for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                  if (mask[(y + dy) * width + (x + dx)]) {
                    shouldProcess = true;
                    break;
                  }
                }
                if (shouldProcess) break;
              }
              if (!shouldProcess) continue;
            }

            // Pick random pixel from block
            const rx = Math.min(x + Math.floor(Math.random() * blockSize), width - 1);
            const ry = Math.min(y + Math.floor(Math.random() * blockSize), height - 1);
            const ridx = (ry * width + rx) * 4;
            const r = data[ridx];
            const g = data[ridx + 1];
            const b = data[ridx + 2];

            // Fill block
            for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
              for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                const idx = ((y + dy) * width + (x + dx)) * 4;
                data[idx] = r;
                data[idx + 1] = g;
                data[idx + 2] = b;
              }
            }
          }
        }
      }

      function blur(data, width, height, radius) {
        const copy = new Uint8ClampedArray(data);
        const size = radius * 2 + 1;
        const kernel = 1 / (size * size);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            if (isRegionMode && !mask[y * width + x]) continue;

            let r = 0,
              g = 0,
              b = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const px = Math.min(width - 1, Math.max(0, x + dx));
                const py = Math.min(height - 1, Math.max(0, y + dy));
                const idx = (py * width + px) * 4;
                r += copy[idx];
                g += copy[idx + 1];
                b += copy[idx + 2];
              }
            }
            const idx = (y * width + x) * 4;
            data[idx] = r * kernel;
            data[idx + 1] = g * kernel;
            data[idx + 2] = b * kernel;
          }
        }
      }

      function oilPaint(data, width, height, radius) {
        const copy = new Uint8ClampedArray(data);
        const levels = 20;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            if (isRegionMode && !mask[y * width + x]) continue;

            const intensityCount = new Array(levels).fill(0);
            const avgR = new Array(levels).fill(0);
            const avgG = new Array(levels).fill(0);
            const avgB = new Array(levels).fill(0);

            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const px = Math.min(width - 1, Math.max(0, x + dx));
                const py = Math.min(height - 1, Math.max(0, y + dy));
                const idx = (py * width + px) * 4;

                const r = copy[idx];
                const g = copy[idx + 1];
                const b = copy[idx + 2];
                const intensity = Math.floor((((r + g + b) / 3) * levels) / 256);
                const ci = Math.min(levels - 1, intensity);

                intensityCount[ci]++;
                avgR[ci] += r;
                avgG[ci] += g;
                avgB[ci] += b;
              }
            }

            let maxIndex = 0;
            let maxCount = 0;
            for (let i = 0; i < levels; i++) {
              if (intensityCount[i] > maxCount) {
                maxCount = intensityCount[i];
                maxIndex = i;
              }
            }

            const idx = (y * width + x) * 4;
            if (maxCount > 0) {
              data[idx] = avgR[maxIndex] / maxCount;
              data[idx + 1] = avgG[maxIndex] / maxCount;
              data[idx + 2] = avgB[maxIndex] / maxCount;
            }
          }
        }
      }

      window.resetImage = function () {
        if (!originalImage) return;
        ctx.drawImage(originalImage, 0, 0);
        if (mask) mask.fill(0);
      };

      window.downloadImage = function () {
        const link = document.createElement("a");
        link.download = "pixelated-image.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      };

      window.updatePreview = function () {
        document.getElementById("intensityVal").textContent =
          document.getElementById("intensity").value;
      };
    </script>
  </body>
</html>
