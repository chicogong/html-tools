<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å›¾ç‰‡æ‹¼æ¥å™¨ - WebUtils</title>
    <!-- SEO Meta Tags -->
    <meta name="description" content="å›¾ç‰‡æ‹¼æ¥å™¨ - WebUtils" />
    <meta name="keywords" content="image-stitcher,media,tools,webutils" />
    <meta name="author" content="WebUtils" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://tools.realtime-ai.chat/tools/media/image-stitcher.html" />

    <!-- Open Graph -->
    <meta property="og:title" content="å›¾ç‰‡æ‹¼æ¥å™¨ - WebUtils" />
    <meta property="og:description" content="å›¾ç‰‡æ‹¼æ¥å™¨ - WebUtils" />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://tools.realtime-ai.chat/tools/media/image-stitcher.html"
    />
    <meta property="og:site_name" content="WebUtils" />
    <meta property="og:locale" content="zh_CN" />
    <meta property="og:image" content="https://tools.realtime-ai.chat/social-preview.png" />
    <meta property="og:image:width" content="1280" />
    <meta property="og:image:height" content="640" />
    <meta property="og:image:type" content="image/png" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="å›¾ç‰‡æ‹¼æ¥å™¨ - WebUtils" />
    <meta name="twitter:description" content="å›¾ç‰‡æ‹¼æ¥å™¨ - WebUtils" />
    <meta name="twitter:image" content="https://tools.realtime-ai.chat/social-preview.png" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <style>
      :root {
        --bg-deep: #0a0a0f;
        --bg-surface: #12121a;
        --bg-card: #1a1a24;
        --bg-input: #0e0e14;
        --text-primary: #e8e8ed;
        --text-secondary: #8888a0;
        --text-muted: #55556a;
        --border-subtle: #2a2a3a;
        --border-strong: #3a3a4a;
        --accent-cyan: #00f5d4;
        --accent-green: #10b981;
        --accent-red: #f43f5e;
        --accent-yellow: #fbbf24;
        --accent-purple: #a855f7;
        --glow-cyan: rgb(0, 245, 212, 0.15);
        --glow-green: rgb(16, 185, 129, 0.15);
        --glow-red: rgb(244, 63, 94, 0.15);
        --radius-sm: 4px;
        --radius-md: 8px;
        --radius-lg: 12px;
      }

      [data-theme="light"] {
        --bg-deep: #fafafa;
        --bg-surface: #fff;
        --bg-card: #fff;
        --bg-input: #f5f5f5;
        --bg-hover: #f5f5f5;
        --text-primary: #1a1a1a;
        --text-secondary: #666;
        --text-muted: #999;
        --border-subtle: #e5e5e5;
        --border-strong: #d5d5d5;
      }

      :root {
        --primary-color: #8b5cf6;
        --success-color: #10b981;
        --warning-color: #f59e0b;
      }

      body {
        padding: 1rem;
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
        gap: 1rem;
      }

      header h1 {
        margin: 0;
        font-size: 1.75rem;
      }

      .theme-toggle {
        cursor: pointer;
        background: var(--primary-color);
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        color: white;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 300px 1fr;
        gap: 1.5rem;
      }

      @media (max-width: 900px) {
        .main-grid {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: var(--card-background-color);
        border-radius: 12px;
        padding: 1.5rem;
        border: 1px solid var(--muted-border-color);
      }

      .panel h3 {
        margin-top: 0;
        margin-bottom: 1rem;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .drop-zone {
        border: 2px dashed var(--muted-border-color);
        border-radius: 12px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 1rem;
      }

      .drop-zone:hover,
      .drop-zone.dragover {
        border-color: var(--primary-color);
        background: rgba(139, 92, 246, 0.1);
      }

      .drop-zone input {
        display: none;
      }

      .drop-zone .icon {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
      }

      .image-list {
        max-height: 400px;
        overflow-y: auto;
      }

      .image-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem;
        background: var(--code-background-color);
        border-radius: 8px;
        margin-bottom: 0.5rem;
        cursor: grab;
      }

      .image-item:active {
        cursor: grabbing;
      }

      .image-item.dragging {
        opacity: 0.5;
      }

      .image-item img {
        width: 50px;
        height: 50px;
        object-fit: cover;
        border-radius: 4px;
      }

      .image-item .info {
        flex: 1;
        min-width: 0;
      }

      .image-item .name {
        font-size: 0.8rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .image-item .size {
        font-size: 0.7rem;
        color: var(--muted-color);
      }

      .image-item .remove {
        background: none;
        border: none;
        color: #ef4444;
        cursor: pointer;
        padding: 0.25rem;
        font-size: 1.2rem;
      }

      .option-group {
        margin-bottom: 1rem;
      }

      .option-group label {
        display: block;
        font-size: 0.85rem;
        margin-bottom: 0.25rem;
        font-weight: 500;
      }

      .radio-group {
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .radio-group label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        font-weight: normal;
      }

      .color-input {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .color-input input[type="color"] {
        width: 50px;
        height: 35px;
        padding: 0;
        border: none;
        cursor: pointer;
      }

      .preview-area {
        min-height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: repeating-conic-gradient(#80808020 0% 25%, transparent 0% 50%) 50% / 20px 20px;
        border-radius: 8px;
        overflow: auto;
        position: relative;
      }

      .preview-area canvas {
        max-width: 100%;
        max-height: 600px;
        object-fit: contain;
      }

      .preview-placeholder {
        color: var(--muted-color);
        text-align: center;
      }

      .preview-placeholder .icon {
        font-size: 3rem;
        margin-bottom: 0.5rem;
      }

      .action-buttons {
        display: flex;
        gap: 0.75rem;
        margin-top: 1rem;
        flex-wrap: wrap;
      }

      .action-buttons button {
        flex: 1;
        min-width: 120px;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--muted-border-color);
      }

      .stat-item {
        text-align: center;
      }

      .stat-item .label {
        font-size: 0.7rem;
        color: var(--muted-color);
      }

      .stat-item .value {
        font-size: 0.9rem;
        font-weight: 600;
      }

      .btn-primary {
        background: var(--primary-color);
        border-color: var(--primary-color);
      }

      .btn-success {
        background: var(--success-color);
        border-color: var(--success-color);
      }

      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 1rem 1.5rem;
        background: var(--primary-color);
        color: white;
        border-radius: 8px;
        z-index: 1000;
        animation: slide-in 0.3s ease;
      }

      @keyframes slide-in {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .breadcrumb {
        background: rgba(255, 255, 255, 0.95);
        padding: 8px 15px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        font-size: 0.85rem;
      }
      .breadcrumb a {
        color: #667eea;
        text-decoration: none;
      }
      .breadcrumb a:hover {
        text-decoration: underline;
      }
      .breadcrumb span {
        color: #999;
        margin: 0 5px;
      }
    </style>
  </head>
  <body>
    <nav class="breadcrumb">
      <a href="../../index.html">é¦–é¡µ</a>
      <span>â€º</span>
      å›¾ç‰‡æ‹¼æ¥å™¨
    </nav>
    <div class="container">
      <header>
        <h1>ğŸ–¼ï¸ å›¾ç‰‡æ‹¼æ¥å™¨</h1>
        <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ“ åˆ‡æ¢ä¸»é¢˜</button>
      </header>

      <div class="main-grid">
        <aside>
          <div class="panel">
            <h3>ğŸ“ æ·»åŠ å›¾ç‰‡</h3>
            <div class="drop-zone" id="dropZone">
              <input type="file" id="fileInput" multiple accept="image/*" />
              <div class="icon">ğŸ“·</div>
              <p>
                æ‹–æ”¾å›¾ç‰‡åˆ°è¿™é‡Œ
                <br />
                <small>æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</small>
              </p>
            </div>

            <div class="image-list" id="imageList"></div>

            <button class="outline" style="width: 100%; margin-top: 0.5rem" onclick="clearAll()">
              ğŸ—‘ï¸ æ¸…ç©ºå…¨éƒ¨
            </button>
          </div>

          <div class="panel" style="margin-top: 1rem">
            <h3>âš™ï¸ æ‹¼æ¥é€‰é¡¹</h3>

            <div class="option-group">
              <label>æ‹¼æ¥æ–¹å‘</label>
              <div class="radio-group">
                <label>
                  <input
                    type="radio"
                    name="direction"
                    value="horizontal"
                    checked
                    onchange="updatePreview()"
                  />
                  â†”ï¸ æ¨ªå‘
                </label>
                <label>
                  <input
                    type="radio"
                    name="direction"
                    value="vertical"
                    onchange="updatePreview()"
                  />
                  â†•ï¸ çºµå‘
                </label>
                <label>
                  <input type="radio" name="direction" value="grid" onchange="updatePreview()" />
                  âŠ ç½‘æ ¼
                </label>
              </div>
            </div>

            <div class="option-group" id="gridOptions" style="display: none">
              <label>ç½‘æ ¼åˆ—æ•°</label>
              <input
                type="number"
                id="gridCols"
                value="2"
                min="1"
                max="10"
                onchange="updatePreview()"
              />
            </div>

            <div class="option-group">
              <label>å›¾ç‰‡é—´è· (px)</label>
              <input
                type="range"
                id="spacing"
                value="0"
                min="0"
                max="50"
                oninput="
                  this.nextElementSibling.textContent = this.value + 'px';
                  updatePreview();
                "
              />
              <span>0px</span>
            </div>

            <div class="option-group">
              <label>èƒŒæ™¯é¢œè‰²</label>
              <div class="color-input">
                <input type="color" id="bgColor" value="#ffffff" onchange="updatePreview()" />
                <label>
                  <input type="checkbox" id="transparent" onchange="updatePreview()" />
                  é€æ˜èƒŒæ™¯
                </label>
              </div>
            </div>

            <div class="option-group">
              <label>å°ºå¯¸è°ƒæ•´</label>
              <div class="radio-group">
                <label>
                  <input
                    type="radio"
                    name="resize"
                    value="none"
                    checked
                    onchange="updatePreview()"
                  />
                  ä¿æŒåŸå°ºå¯¸
                </label>
                <label>
                  <input type="radio" name="resize" value="width" onchange="updatePreview()" />
                  ç»Ÿä¸€å®½åº¦
                </label>
                <label>
                  <input type="radio" name="resize" value="height" onchange="updatePreview()" />
                  ç»Ÿä¸€é«˜åº¦
                </label>
              </div>
            </div>

            <div class="option-group">
              <label>è¾“å‡ºæ ¼å¼</label>
              <select id="outputFormat">
                <option value="png">PNG (æ— æŸ)</option>
                <option value="jpeg">JPEG (å‹ç¼©)</option>
                <option value="webp">WebP (é«˜æ•ˆ)</option>
              </select>
            </div>

            <div class="option-group" id="qualityGroup">
              <label>è¾“å‡ºè´¨é‡</label>
              <input
                type="range"
                id="quality"
                value="92"
                min="1"
                max="100"
                oninput="this.nextElementSibling.textContent = this.value + '%'"
              />
              <span>92%</span>
            </div>
          </div>
        </aside>

        <main>
          <div class="panel">
            <h3>ğŸ‘ï¸ é¢„è§ˆ</h3>
            <div class="preview-area" id="previewArea">
              <div class="preview-placeholder">
                <div class="icon">ğŸ–¼ï¸</div>
                <p>æ·»åŠ å›¾ç‰‡åé¢„è§ˆæ‹¼æ¥æ•ˆæœ</p>
              </div>
            </div>

            <div class="stats" id="stats" style="display: none">
              <div class="stat-item">
                <div class="label">å›¾ç‰‡æ•°é‡</div>
                <div class="value" id="statCount">0</div>
              </div>
              <div class="stat-item">
                <div class="label">è¾“å‡ºå°ºå¯¸</div>
                <div class="value" id="statSize">0 Ã— 0</div>
              </div>
              <div class="stat-item">
                <div class="label">é¢„ä¼°å¤§å°</div>
                <div class="value" id="statFileSize">-</div>
              </div>
            </div>

            <div class="action-buttons">
              <button class="btn-primary" onclick="updatePreview()">ğŸ”„ åˆ·æ–°é¢„è§ˆ</button>
              <button class="btn-success" onclick="downloadImage()">ğŸ’¾ ä¸‹è½½å›¾ç‰‡</button>
              <button onclick="copyToClipboard()">ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
            </div>
          </div>
        </main>
      </div>
    </div>

    <script>
      // å›¾ç‰‡æ•°æ®
      let images = [];
      let canvas = null;
      let draggedItem = null;

      // åˆå§‹åŒ–
      document.addEventListener("DOMContentLoaded", () => {
        initTheme();
        initDropZone();
      });

      // ä¸»é¢˜åˆ‡æ¢
      function initTheme() {
        const saved = localStorage.getItem("theme");
        if (saved) {
          document.documentElement.setAttribute("data-theme", saved);
        }
      }

      window.toggleTheme = function () {
        const current = document.documentElement.getAttribute("data-theme");
        const next = current === "dark" ? "light" : "dark";
        document.documentElement.setAttribute("data-theme", next);
        localStorage.setItem("theme", next);
      };

      // åˆå§‹åŒ–æ‹–æ”¾åŒºåŸŸ
      function initDropZone() {
        const dropZone = document.getElementById("dropZone");
        const fileInput = document.getElementById("fileInput");

        dropZone.addEventListener("click", () => fileInput.click());

        dropZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropZone.classList.add("dragover");
        });

        dropZone.addEventListener("dragleave", () => {
          dropZone.classList.remove("dragover");
        });

        dropZone.addEventListener("drop", (e) => {
          e.preventDefault();
          dropZone.classList.remove("dragover");
          handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener("change", (e) => {
          handleFiles(e.target.files);
          e.target.value = "";
        });
      }

      // å¤„ç†æ–‡ä»¶
      function handleFiles(files) {
        Array.from(files).forEach((file) => {
          if (!file.type.startsWith("image/")) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              images.push({
                id: Date.now() + Math.random(),
                name: file.name,
                width: img.width,
                height: img.height,
                size: file.size,
                element: img,
                dataUrl: e.target.result
              });
              renderImageList();
              updatePreview();
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      }

      // æ¸²æŸ“å›¾ç‰‡åˆ—è¡¨
      function renderImageList() {
        const list = document.getElementById("imageList");
        list.innerHTML = images
          .map(
            (img, index) => `
                <div class="image-item" draggable="true" data-index="${index}">
                    <img src="${img.dataUrl}" alt="${img.name}">
                    <div class="info">
                        <div class="name">${img.name}</div>
                        <div class="size">${img.width}Ã—${img.height} Â· ${formatSize(img.size)}</div>
                    </div>
                    <button class="remove" onclick="removeImage(${index})">Ã—</button>
                </div>
            `
          )
          .join("");

        // æ·»åŠ æ‹–æ‹½æ’åº
        list.querySelectorAll(".image-item").forEach((item) => {
          item.addEventListener("dragstart", handleDragStart);
          item.addEventListener("dragover", handleDragOver);
          item.addEventListener("drop", handleDrop);
          item.addEventListener("dragend", handleDragEnd);
        });
      }

      // æ‹–æ‹½æ’åºå¤„ç†
      function handleDragStart(e) {
        draggedItem = this;
        this.classList.add("dragging");
      }

      function handleDragOver(e) {
        e.preventDefault();
      }

      function handleDrop(e) {
        e.preventDefault();
        if (this !== draggedItem) {
          const fromIndex = parseInt(draggedItem.dataset.index);
          const toIndex = parseInt(this.dataset.index);
          const [moved] = images.splice(fromIndex, 1);
          images.splice(toIndex, 0, moved);
          renderImageList();
          updatePreview();
        }
      }

      function handleDragEnd() {
        this.classList.remove("dragging");
        draggedItem = null;
      }

      // åˆ é™¤å›¾ç‰‡
      window.removeImage = function (index) {
        images.splice(index, 1);
        renderImageList();
        updatePreview();
      };

      // æ¸…ç©ºå…¨éƒ¨
      window.clearAll = function () {
        images = [];
        renderImageList();
        document.getElementById("previewArea").innerHTML = `
                <div class="preview-placeholder">
                    <div class="icon">ğŸ–¼ï¸</div>
                    <p>æ·»åŠ å›¾ç‰‡åé¢„è§ˆæ‹¼æ¥æ•ˆæœ</p>
                </div>
            `;
        document.getElementById("stats").style.display = "none";
      };

      // æ›´æ–°é¢„è§ˆ
      window.updatePreview = function () {
        if (images.length === 0) {
          clearAll();
          return;
        }

        const direction = document.querySelector('input[name="direction"]:checked').value;
        const spacing = parseInt(document.getElementById("spacing").value);
        const bgColor = document.getElementById("bgColor").value;
        const transparent = document.getElementById("transparent").checked;
        const resize = document.querySelector('input[name="resize"]:checked').value;
        const gridCols = parseInt(document.getElementById("gridCols").value);

        // æ˜¾ç¤º/éšè—ç½‘æ ¼é€‰é¡¹
        document.getElementById("gridOptions").style.display =
          direction === "grid" ? "block" : "none";

        // è®¡ç®—ç»Ÿä¸€å°ºå¯¸
        let targetWidth, targetHeight;
        if (resize === "width") {
          targetWidth = Math.min(...images.map((img) => img.width));
        } else if (resize === "height") {
          targetHeight = Math.min(...images.map((img) => img.height));
        }

        // è®¡ç®—æ¯å¼ å›¾ç‰‡çš„ç»˜åˆ¶å°ºå¯¸
        const drawSizes = images.map((img) => {
          let w = img.width;
          let h = img.height;
          if (resize === "width" && targetWidth) {
            h = (h / w) * targetWidth;
            w = targetWidth;
          } else if (resize === "height" && targetHeight) {
            w = (w / h) * targetHeight;
            h = targetHeight;
          }
          return { width: Math.round(w), height: Math.round(h) };
        });

        // è®¡ç®—ç”»å¸ƒå°ºå¯¸
        let canvasWidth, canvasHeight;

        if (direction === "horizontal") {
          canvasWidth =
            drawSizes.reduce((sum, s) => sum + s.width, 0) + spacing * (images.length - 1);
          canvasHeight = Math.max(...drawSizes.map((s) => s.height));
        } else if (direction === "vertical") {
          canvasWidth = Math.max(...drawSizes.map((s) => s.width));
          canvasHeight =
            drawSizes.reduce((sum, s) => sum + s.height, 0) + spacing * (images.length - 1);
        } else {
          // ç½‘æ ¼å¸ƒå±€
          const rows = Math.ceil(images.length / gridCols);
          const maxWidthPerCol = [];
          const maxHeightPerRow = [];

          for (let i = 0; i < images.length; i++) {
            const col = i % gridCols;
            const row = Math.floor(i / gridCols);
            maxWidthPerCol[col] = Math.max(maxWidthPerCol[col] || 0, drawSizes[i].width);
            maxHeightPerRow[row] = Math.max(maxHeightPerRow[row] || 0, drawSizes[i].height);
          }

          canvasWidth = maxWidthPerCol.reduce((a, b) => a + b, 0) + spacing * (gridCols - 1);
          canvasHeight = maxHeightPerRow.reduce((a, b) => a + b, 0) + spacing * (rows - 1);
        }

        // åˆ›å»ºç”»å¸ƒ
        canvas = document.createElement("canvas");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext("2d");

        // å¡«å……èƒŒæ™¯
        if (!transparent) {
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        // ç»˜åˆ¶å›¾ç‰‡
        let x = 0,
          y = 0;

        if (direction === "horizontal") {
          images.forEach((img, i) => {
            const yOffset = Math.floor((canvasHeight - drawSizes[i].height) / 2);
            ctx.drawImage(img.element, x, yOffset, drawSizes[i].width, drawSizes[i].height);
            x += drawSizes[i].width + spacing;
          });
        } else if (direction === "vertical") {
          images.forEach((img, i) => {
            const xOffset = Math.floor((canvasWidth - drawSizes[i].width) / 2);
            ctx.drawImage(img.element, xOffset, y, drawSizes[i].width, drawSizes[i].height);
            y += drawSizes[i].height + spacing;
          });
        } else {
          // ç½‘æ ¼å¸ƒå±€
          const rows = Math.ceil(images.length / gridCols);
          const maxWidthPerCol = [];
          const maxHeightPerRow = [];

          for (let i = 0; i < images.length; i++) {
            const col = i % gridCols;
            const row = Math.floor(i / gridCols);
            maxWidthPerCol[col] = Math.max(maxWidthPerCol[col] || 0, drawSizes[i].width);
            maxHeightPerRow[row] = Math.max(maxHeightPerRow[row] || 0, drawSizes[i].height);
          }

          images.forEach((img, i) => {
            const col = i % gridCols;
            const row = Math.floor(i / gridCols);

            let posX = 0;
            for (let c = 0; c < col; c++) {
              posX += maxWidthPerCol[c] + spacing;
            }
            posX += Math.floor((maxWidthPerCol[col] - drawSizes[i].width) / 2);

            let posY = 0;
            for (let r = 0; r < row; r++) {
              posY += maxHeightPerRow[r] + spacing;
            }
            posY += Math.floor((maxHeightPerRow[row] - drawSizes[i].height) / 2);

            ctx.drawImage(img.element, posX, posY, drawSizes[i].width, drawSizes[i].height);
          });
        }

        // æ˜¾ç¤ºé¢„è§ˆ
        const previewArea = document.getElementById("previewArea");
        previewArea.innerHTML = "";
        previewArea.appendChild(canvas);

        // æ›´æ–°ç»Ÿè®¡
        document.getElementById("stats").style.display = "grid";
        document.getElementById("statCount").textContent = images.length;
        document.getElementById("statSize").textContent = `${canvasWidth} Ã— ${canvasHeight}`;

        // é¢„ä¼°æ–‡ä»¶å¤§å°
        const format = document.getElementById("outputFormat").value;
        const quality = parseInt(document.getElementById("quality").value) / 100;
        canvas.toBlob(
          (blob) => {
            if (blob) {
              document.getElementById("statFileSize").textContent = formatSize(blob.size);
            }
          },
          `image/${format}`,
          quality
        );
      };

      // ä¸‹è½½å›¾ç‰‡
      window.downloadImage = function () {
        if (!canvas) {
          showToast("è¯·å…ˆæ·»åŠ å›¾ç‰‡");
          return;
        }

        const format = document.getElementById("outputFormat").value;
        const quality = parseInt(document.getElementById("quality").value) / 100;
        const transparent = document.getElementById("transparent").checked;

        let mimeType = `image/${format}`;
        if (transparent && format === "jpeg") {
          mimeType = "image/png";
        }

        canvas.toBlob(
          (blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `stitched-image.${format === "jpeg" ? "jpg" : format}`;
            a.click();
            URL.revokeObjectURL(url);
            showToast("å›¾ç‰‡å·²ä¸‹è½½");
          },
          mimeType,
          quality
        );
      };

      // å¤åˆ¶åˆ°å‰ªè´´æ¿
      window.copyToClipboard = async function () {
        if (!canvas) {
          showToast("è¯·å…ˆæ·»åŠ å›¾ç‰‡");
          return;
        }

        try {
          const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
          await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
          showToast("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
        } catch (err) {
          showToast("å¤åˆ¶å¤±è´¥: " + err.message);
        }
      };

      // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
      function formatSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
        return (bytes / (1024 * 1024)).toFixed(2) + " MB";
      }

      // Toast æç¤º
      function showToast(message) {
        const existing = document.querySelector(".toast");
        if (existing) existing.remove();

        const toast = document.createElement("div");
        toast.className = "toast";
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => toast.remove(), 2500);
      }

      // ç›‘å¬æ ¼å¼å˜åŒ–
      document.getElementById("outputFormat").addEventListener("change", function () {
        document.getElementById("qualityGroup").style.display =
          this.value === "png" ? "none" : "block";
      });
    </script>
  </body>
</html>
