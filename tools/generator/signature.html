<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>签名生成器</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <style>
        :root {
            --preview-bg: #f0f0f0;
        }
        [data-theme="dark"] {
            --preview-bg: #2a2a2a;
        }
        body {
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        .preview-area {
            background: var(--preview-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .canvas-wrapper {
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #signatureCanvas {
            display: block;
            cursor: crosshair;
            border-radius: 8px;
            touch-action: none;
        }
        .canvas-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-size: 1.2rem;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .control-group {
            padding: 1rem;
            background: var(--pico-card-background-color);
            border-radius: 8px;
        }
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
        }
        .color-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .color-inputs input[type="color"] {
            width: 60px;
            height: 40px;
            padding: 2px;
            cursor: pointer;
        }
        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .range-value {
            font-weight: bold;
            color: var(--pico-primary);
        }
        .color-presets {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .color-preset {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s, transform 0.2s;
        }
        .color-preset:hover {
            transform: scale(1.1);
        }
        .color-preset.active {
            border-color: var(--pico-primary);
        }
        .bg-options {
            display: flex;
            gap: 0.5rem;
        }
        .bg-option {
            padding: 0.5rem 1rem;
            border: 2px solid var(--pico-muted-border-color);
            border-radius: 4px;
            cursor: pointer;
            background: none;
            color: var(--pico-color);
        }
        .bg-option:hover {
            border-color: var(--pico-primary);
        }
        .bg-option.active {
            border-color: var(--pico-primary);
            background: var(--pico-primary-focus);
        }
        .undo-redo {
            display: flex;
            gap: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>签名生成器</h1>
            <button id="themeToggle" class="outline">切换主题</button>
        </header>

        <div class="preview-area">
            <div class="canvas-wrapper">
                <canvas id="signatureCanvas" width="600" height="300"></canvas>
                <div class="canvas-placeholder" id="placeholder">在此处签名</div>
            </div>
            <div class="undo-redo">
                <button id="undoBtn" class="outline secondary">撤销</button>
                <button id="redoBtn" class="outline secondary">重做</button>
                <button id="clearBtn" class="outline secondary">清除</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>笔触颜色</label>
                <div class="color-inputs">
                    <input type="color" id="strokeColor" value="#000000">
                    <input type="text" id="strokeColorText" value="#000000" maxlength="7">
                </div>
                <div class="color-presets">
                    <div class="color-preset active" style="background: #000000" data-color="#000000"></div>
                    <div class="color-preset" style="background: #1a365d" data-color="#1a365d"></div>
                    <div class="color-preset" style="background: #2d3748" data-color="#2d3748"></div>
                    <div class="color-preset" style="background: #1e40af" data-color="#1e40af"></div>
                    <div class="color-preset" style="background: #7c3aed" data-color="#7c3aed"></div>
                    <div class="color-preset" style="background: #dc2626" data-color="#dc2626"></div>
                </div>
            </div>

            <div class="control-group">
                <label>笔触粗细: <span class="range-value" id="strokeWidthValue">3</span>px</label>
                <input type="range" id="strokeWidth" min="1" max="15" value="3">
            </div>

            <div class="control-group">
                <label>平滑度: <span class="range-value" id="smoothnessValue">5</span></label>
                <input type="range" id="smoothness" min="1" max="10" value="5">
            </div>

            <div class="control-group">
                <label>背景类型</label>
                <div class="bg-options">
                    <button class="bg-option active" data-bg="transparent">透明</button>
                    <button class="bg-option" data-bg="white">白色</button>
                    <button class="bg-option" data-bg="custom">自定义</button>
                </div>
                <div id="customBgColor" style="display: none; margin-top: 0.5rem;">
                    <div class="color-inputs">
                        <input type="color" id="bgColor" value="#ffffff">
                        <input type="text" id="bgColorText" value="#ffffff" maxlength="7">
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>画布尺寸</label>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="number" id="canvasWidth" value="600" min="200" max="1200" style="width: 100px;">
                    <span style="line-height: 40px;">x</span>
                    <input type="number" id="canvasHeight" value="300" min="100" max="600" style="width: 100px;">
                    <button id="resizeCanvas" class="outline">调整</button>
                </div>
            </div>

            <div class="control-group">
                <label>笔触样式</label>
                <select id="penStyle">
                    <option value="round">圆形笔触</option>
                    <option value="square">方形笔触</option>
                    <option value="butt">平头笔触</option>
                </select>
            </div>
        </div>

        <div class="btn-group">
            <button id="downloadPng" class="outline">下载 PNG</button>
            <button id="downloadJpg" class="outline">下载 JPG</button>
            <button id="downloadSvg" class="outline">下载 SVG</button>
            <button id="copyImage" class="outline">复制图片</button>
        </div>
    </div>

    <script>
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', function() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            html.setAttribute('data-theme', currentTheme === 'dark' ? 'light' : 'dark');
        });

        // Canvas setup
        const canvas = document.getElementById('signatureCanvas');
        const ctx = canvas.getContext('2d');
        const placeholder = document.getElementById('placeholder');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let paths = [];
        let currentPath = [];
        let undoStack = [];
        let redoStack = [];
        let bgType = 'transparent';

        // Elements
        const strokeColor = document.getElementById('strokeColor');
        const strokeColorText = document.getElementById('strokeColorText');
        const strokeWidth = document.getElementById('strokeWidth');
        const smoothness = document.getElementById('smoothness');
        const bgColor = document.getElementById('bgColor');
        const bgColorText = document.getElementById('bgColorText');
        const penStyle = document.getElementById('penStyle');

        // Sync color inputs
        function syncColorInputs(colorInput, textInput, callback) {
            colorInput.addEventListener('input', function() {
                textInput.value = colorInput.value;
                if (callback) callback();
            });
            textInput.addEventListener('input', function() {
                if (/^#[0-9A-Fa-f]{6}$/.test(textInput.value)) {
                    colorInput.value = textInput.value;
                    if (callback) callback();
                }
            });
        }

        syncColorInputs(strokeColor, strokeColorText);
        syncColorInputs(bgColor, bgColorText, redrawCanvas);

        // Color presets
        document.querySelectorAll('.color-preset').forEach(function(preset) {
            preset.addEventListener('click', function() {
                document.querySelectorAll('.color-preset').forEach(function(p) { p.classList.remove('active'); });
                preset.classList.add('active');
                strokeColor.value = preset.dataset.color;
                strokeColorText.value = preset.dataset.color;
            });
        });

        // Background options
        document.querySelectorAll('.bg-option').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.bg-option').forEach(function(b) { b.classList.remove('active'); });
                btn.classList.add('active');
                bgType = btn.dataset.bg;
                document.getElementById('customBgColor').style.display = bgType === 'custom' ? 'block' : 'none';
                redrawCanvas();
            });
        });

        // Update range values
        strokeWidth.addEventListener('input', function() {
            document.getElementById('strokeWidthValue').textContent = strokeWidth.value;
        });
        smoothness.addEventListener('input', function() {
            document.getElementById('smoothnessValue').textContent = smoothness.value;
        });

        // Resize canvas
        document.getElementById('resizeCanvas').addEventListener('click', function() {
            const newWidth = parseInt(document.getElementById('canvasWidth').value);
            const newHeight = parseInt(document.getElementById('canvasHeight').value);
            
            // Save current image
            const imageData = canvas.toDataURL();
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Redraw paths
            redrawCanvas();
        });

        // Get mouse/touch position
        function getPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            }
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // Start drawing
        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const pos = getPosition(e);
            lastX = pos.x;
            lastY = pos.y;
            currentPath = [{
                x: pos.x,
                y: pos.y,
                color: strokeColor.value,
                width: parseInt(strokeWidth.value),
                style: penStyle.value
            }];
            placeholder.style.opacity = '0';
        }

        // Draw
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getPosition(e);
            const smooth = parseInt(smoothness.value);
            
            ctx.strokeStyle = strokeColor.value;
            ctx.lineWidth = parseInt(strokeWidth.value);
            ctx.lineCap = penStyle.value;
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            
            // Smoothing with quadratic curve
            const midX = (lastX + pos.x) / 2;
            const midY = (lastY + pos.y) / 2;
            
            if (smooth > 5) {
                ctx.quadraticCurveTo(lastX, lastY, midX, midY);
            } else {
                ctx.lineTo(pos.x, pos.y);
            }
            
            ctx.stroke();

            currentPath.push({
                x: pos.x,
                y: pos.y,
                color: strokeColor.value,
                width: parseInt(strokeWidth.value),
                style: penStyle.value
            });

            lastX = pos.x;
            lastY = pos.y;
        }

        // Stop drawing
        function stopDrawing() {
            if (isDrawing && currentPath.length > 0) {
                paths.push(currentPath.slice());
                undoStack.push(currentPath.slice());
                redoStack = [];
            }
            isDrawing = false;
            currentPath = [];
        }

        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch events
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        // Redraw canvas
        function redrawCanvas() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            if (bgType === 'white') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (bgType === 'custom') {
                ctx.fillStyle = bgColor.value;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Redraw all paths
            paths.forEach(function(path) {
                if (path.length < 2) return;
                
                ctx.strokeStyle = path[0].color;
                ctx.lineWidth = path[0].width;
                ctx.lineCap = path[0].style;
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                
                for (let i = 1; i < path.length; i++) {
                    const midX = (path[i - 1].x + path[i].x) / 2;
                    const midY = (path[i - 1].y + path[i].y) / 2;
                    ctx.quadraticCurveTo(path[i - 1].x, path[i - 1].y, midX, midY);
                }
                
                ctx.stroke();
            });

            // Show/hide placeholder
            placeholder.style.opacity = paths.length === 0 ? '1' : '0';
        }

        // Undo
        document.getElementById('undoBtn').addEventListener('click', function() {
            if (paths.length > 0) {
                redoStack.push(paths.pop());
                redrawCanvas();
            }
        });

        // Redo
        document.getElementById('redoBtn').addEventListener('click', function() {
            if (redoStack.length > 0) {
                paths.push(redoStack.pop());
                redrawCanvas();
            }
        });

        // Clear
        document.getElementById('clearBtn').addEventListener('click', function() {
            if (paths.length > 0) {
                redoStack = redoStack.concat(paths);
                paths = [];
                redrawCanvas();
            }
        });

        // Download PNG
        document.getElementById('downloadPng').addEventListener('click', function() {
            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = 'signature.png';
            a.click();
        });

        // Download JPG
        document.getElementById('downloadJpg').addEventListener('click', function() {
            // Create temp canvas with white background for JPG
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.drawImage(canvas, 0, 0);
            
            const a = document.createElement('a');
            a.href = tempCanvas.toDataURL('image/jpeg', 0.9);
            a.download = 'signature.jpg';
            a.click();
        });

        // Download SVG
        document.getElementById('downloadSvg').addEventListener('click', function() {
            let svgContent = '<?xml version="1.0" encoding="UTF-8"?>\n';
            svgContent += '<svg xmlns="http://www.w3.org/2000/svg" width="' + canvas.width + '" height="' + canvas.height + '" viewBox="0 0 ' + canvas.width + ' ' + canvas.height + '">\n';
            
            // Background
            if (bgType === 'white') {
                svgContent += '  <rect width="100%" height="100%" fill="#ffffff"/>\n';
            } else if (bgType === 'custom') {
                svgContent += '  <rect width="100%" height="100%" fill="' + bgColor.value + '"/>\n';
            }
            
            // Paths
            paths.forEach(function(path) {
                if (path.length < 2) return;
                
                let d = 'M ' + path[0].x + ' ' + path[0].y;
                for (let i = 1; i < path.length; i++) {
                    const midX = (path[i - 1].x + path[i].x) / 2;
                    const midY = (path[i - 1].y + path[i].y) / 2;
                    d += ' Q ' + path[i - 1].x + ' ' + path[i - 1].y + ' ' + midX + ' ' + midY;
                }
                
                svgContent += '  <path d="' + d + '" stroke="' + path[0].color + '" stroke-width="' + path[0].width + '" fill="none" stroke-linecap="' + path[0].style + '" stroke-linejoin="round"/>\n';
            });
            
            svgContent += '</svg>';
            
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'signature.svg';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Copy image
        document.getElementById('copyImage').addEventListener('click', function() {
            canvas.toBlob(function(blob) {
                const item = new ClipboardItem({ 'image/png': blob });
                navigator.clipboard.write([item]).then(function() {
                    alert('图片已复制到剪贴板');
                });
            });
        });

        // Initial canvas setup
        redrawCanvas();
    </script>
</body>
</html>
