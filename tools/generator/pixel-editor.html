<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÉèÁ¥†ÁîªÁºñËæëÂô®</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #00c9ff 0%, #92fe9d 100%);
            --card-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        
        [data-theme="dark"] {
            --card-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        body {
            min-height: 100vh;
            padding: 2rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        header h1 {
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .theme-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--primary-gradient);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--card-shadow);
            transition: transform 0.3s;
            z-index: 1000;
        }
        
        .theme-toggle:hover {
            transform: scale(1.1);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 2rem;
            align-items: start;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .controls {
            background: var(--pico-card-background-color);
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--card-shadow);
        }
        
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-group label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: block;
        }
        
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .tool-btn {
            aspect-ratio: 1;
            border: 2px solid var(--pico-muted-border-color);
            border-radius: 0.5rem;
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tool-btn:hover, .tool-btn.active {
            border-color: #00c9ff;
            background: rgba(0, 201, 255, 0.1);
        }
        
        .color-picker-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .current-colors {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .color-box {
            width: 50px;
            height: 50px;
            border-radius: 0.5rem;
            border: 2px solid var(--pico-muted-border-color);
            cursor: pointer;
            position: relative;
        }
        
        .color-box.primary {
            z-index: 2;
        }
        
        .color-box.secondary {
            margin-left: -15px;
        }
        
        .color-input {
            width: 100%;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        
        .palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 0.5rem;
        }
        
        .palette-color {
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .palette-color:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        
        .size-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }
        
        .size-btn {
            padding: 0.5rem;
            border: 2px solid var(--pico-muted-border-color);
            border-radius: 0.5rem;
            background: transparent;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }
        
        .size-btn:hover, .size-btn.active {
            border-color: #00c9ff;
            background: rgba(0, 201, 255, 0.1);
        }
        
        .preview-area {
            background: var(--pico-card-background-color);
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--card-shadow);
        }
        
        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            background: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%) 50% / 20px 20px;
            border-radius: 0.5rem;
            padding: 1rem;
            min-height: 500px;
            overflow: auto;
        }
        
        [data-theme="dark"] .canvas-wrapper {
            background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 20px 20px;
        }
        
        #pixelCanvas {
            image-rendering: pixelated;
            cursor: crosshair;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        
        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .btn-group button {
            flex: 1;
            min-width: 100px;
        }
        
        .btn-primary {
            background: var(--primary-gradient);
            border: none;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--pico-muted-border-color);
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .zoom-btn:hover {
            border-color: #00c9ff;
            background: rgba(0, 201, 255, 0.1);
        }
        
        .zoom-level {
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .preview-small {
            margin-top: 1rem;
            text-align: center;
        }
        
        .preview-small canvas {
            image-rendering: pixelated;
            border: 2px solid var(--pico-muted-border-color);
            border-radius: 0.5rem;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="toggleTheme()">üåì</button>
    
    <div class="container">
        <a href="../../index.html" style="display:inline-block;margin-bottom:1rem;color:var(--pico-primary);text-decoration:none;">‚Üê ËøîÂõûÈ¶ñÈ°µ</a>
        <header>
            <h1>üé® ÂÉèÁ¥†ÁîªÁºñËæëÂô®</h1>
            <p>ÂàõÂª∫Â§çÂè§È£éÊ†ºÁöÑÂÉèÁ¥†Ëâ∫ÊúØ‰ΩúÂìÅ</p>
        </header>
        
        <div class="main-content">
            <div class="controls">
                <div class="control-group">
                    <label>üõ†Ô∏è Â∑•ÂÖ∑</label>
                    <div class="tools-grid">
                        <button class="tool-btn active" data-tool="pencil" title="ÁîªÁ¨î">‚úèÔ∏è</button>
                        <button class="tool-btn" data-tool="eraser" title="Ê©°ÁöÆÊì¶">üßπ</button>
                        <button class="tool-btn" data-tool="fill" title="Â°´ÂÖÖ">ü™£</button>
                        <button class="tool-btn" data-tool="picker" title="ÂèñËâ≤">üíâ</button>
                        <button class="tool-btn" data-tool="line" title="Áõ¥Á∫ø">üìè</button>
                        <button class="tool-btn" data-tool="rect" title="Áü©ÂΩ¢">‚¨ú</button>
                        <button class="tool-btn" data-tool="circle" title="ÂúÜÂΩ¢">‚≠ï</button>
                        <button class="tool-btn" data-tool="move" title="ÁßªÂä®">‚úã</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>üé® È¢úËâ≤</label>
                    <div class="color-picker-container">
                        <div class="current-colors">
                            <div class="color-box primary" id="primaryColor" style="background: #000"></div>
                            <div class="color-box secondary" id="secondaryColor" style="background: #fff"></div>
                            <button onclick="swapColors()" style="margin-left: auto; padding: 0.5rem;">üîÑ</button>
                        </div>
                        <input type="color" class="color-input" id="colorPicker" value="#000000">
                        <div class="palette" id="palette"></div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>üìê ÁîªÂ∏ÉÂ§ßÂ∞è</label>
                    <div class="size-presets">
                        <button class="size-btn" data-size="8">8√ó8</button>
                        <button class="size-btn active" data-size="16">16√ó16</button>
                        <button class="size-btn" data-size="32">32√ó32</button>
                        <button class="size-btn" data-size="48">48√ó48</button>
                        <button class="size-btn" data-size="64">64√ó64</button>
                        <button class="size-btn" data-size="128">128√ó128</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>üñåÔ∏è Á¨îÂà∑Â§ßÂ∞è</label>
                    <input type="range" id="brushSize" min="1" max="8" value="1">
                    <small id="brushSizeLabel">1 ÂÉèÁ¥†</small>
                </div>
                
                <div class="btn-group">
                    <button class="btn-primary" onclick="downloadImage()">üì• ‰∏ãËΩΩ PNG</button>
                    <button onclick="clearCanvas()">üóëÔ∏è Ê∏ÖÁ©∫</button>
                </div>
                
                <div class="btn-group">
                    <button onclick="undo()">‚Ü©Ô∏è Êí§ÈîÄ</button>
                    <button onclick="redo()">‚Ü™Ô∏è ÈáçÂÅö</button>
                </div>
                
                <div class="preview-small">
                    <label>ÂÆûÈôÖÂ§ßÂ∞èÈ¢ÑËßà</label>
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>
            
            <div class="preview-area">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomOut()">‚ûñ</button>
                    <span class="zoom-level" id="zoomLevel">16x</span>
                    <button class="zoom-btn" onclick="zoomIn()">‚ûï</button>
                    <label style="margin-left: 1rem;">
                        <input type="checkbox" id="showGrid" checked> ÊòæÁ§∫ÁΩëÊ†º
                    </label>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="pixelCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Theme management
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }
        
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        
        // Color palette
        const paletteColors = [
            '#000000', '#1D2B53', '#7E2553', '#008751',
            '#AB5236', '#5F574F', '#C2C3C7', '#FFF1E8',
            '#FF004D', '#FFA300', '#FFEC27', '#00E436',
            '#29ADFF', '#83769C', '#FF77A8', '#FFCCAA',
            '#FFFFFF', '#FF0000', '#00FF00', '#0000FF',
            '#FFFF00', '#00FFFF', '#FF00FF', '#808080'
        ];
        
        const paletteEl = document.getElementById('palette');
        paletteColors.forEach(color => {
            const el = document.createElement('div');
            el.className = 'palette-color';
            el.style.background = color;
            el.addEventListener('click', () => {
                state.primaryColor = color;
                document.getElementById('primaryColor').style.background = color;
                document.getElementById('colorPicker').value = color;
            });
            el.addEventListener('contextmenu', e => {
                e.preventDefault();
                state.secondaryColor = color;
                document.getElementById('secondaryColor').style.background = color;
            });
            paletteEl.appendChild(el);
        });
        
        // Canvas setup
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        let state = {
            gridSize: 16,
            zoom: 16,
            primaryColor: '#000000',
            secondaryColor: '#ffffff',
            tool: 'pencil',
            brushSize: 1,
            showGrid: true,
            pixels: [],
            history: [],
            historyIndex: -1,
            isDrawing: false,
            startX: 0,
            startY: 0
        };
        
        function initCanvas() {
            const size = state.gridSize;
            canvas.width = size * state.zoom;
            canvas.height = size * state.zoom;
            previewCanvas.width = size;
            previewCanvas.height = size;
            
            state.pixels = [];
            for (let y = 0; y < size; y++) {
                state.pixels[y] = [];
                for (let x = 0; x < size; x++) {
                    state.pixels[y][x] = null;
                }
            }
            
            state.history = [];
            state.historyIndex = -1;
            saveHistory();
            render();
        }
        
        function render() {
            const size = state.gridSize;
            const cellSize = state.zoom;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw pixels
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (state.pixels[y][x]) {
                        ctx.fillStyle = state.pixels[y][x];
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            // Draw grid
            if (state.showGrid && state.zoom >= 4) {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= size; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * cellSize, 0);
                    ctx.lineTo(i * cellSize, canvas.height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i * cellSize);
                    ctx.lineTo(canvas.width, i * cellSize);
                    ctx.stroke();
                }
            }
            
            // Update preview
            previewCtx.clearRect(0, 0, size, size);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (state.pixels[y][x]) {
                        previewCtx.fillStyle = state.pixels[y][x];
                        previewCtx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }
        
        function getPixelCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / state.zoom);
            const y = Math.floor((e.clientY - rect.top) / state.zoom);
            return { x: Math.max(0, Math.min(x, state.gridSize - 1)), y: Math.max(0, Math.min(y, state.gridSize - 1)) };
        }
        
        function setPixel(x, y, color) {
            if (x >= 0 && x < state.gridSize && y >= 0 && y < state.gridSize) {
                const brushSize = state.brushSize;
                const offset = Math.floor(brushSize / 2);
                
                for (let dy = 0; dy < brushSize; dy++) {
                    for (let dx = 0; dx < brushSize; dx++) {
                        const px = x - offset + dx;
                        const py = y - offset + dy;
                        if (px >= 0 && px < state.gridSize && py >= 0 && py < state.gridSize) {
                            state.pixels[py][px] = color;
                        }
                    }
                }
            }
        }
        
        function floodFill(x, y, targetColor, fillColor) {
            if (targetColor === fillColor) return;
            const stack = [[x, y]];
            
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                if (cx < 0 || cx >= state.gridSize || cy < 0 || cy >= state.gridSize) continue;
                if (state.pixels[cy][cx] !== targetColor) continue;
                
                state.pixels[cy][cx] = fillColor;
                stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
            }
        }
        
        function drawLine(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                setPixel(x0, y0, color);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }
        
        function drawRect(x0, y0, x1, y1, color) {
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);
            
            for (let x = minX; x <= maxX; x++) {
                setPixel(x, minY, color);
                setPixel(x, maxY, color);
            }
            for (let y = minY; y <= maxY; y++) {
                setPixel(minX, y, color);
                setPixel(maxX, y, color);
            }
        }
        
        function drawCircle(x0, y0, x1, y1, color) {
            const radius = Math.floor(Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2));
            let x = radius;
            let y = 0;
            let err = 0;
            
            while (x >= y) {
                setPixel(x0 + x, y0 + y, color);
                setPixel(x0 + y, y0 + x, color);
                setPixel(x0 - y, y0 + x, color);
                setPixel(x0 - x, y0 + y, color);
                setPixel(x0 - x, y0 - y, color);
                setPixel(x0 - y, y0 - x, color);
                setPixel(x0 + y, y0 - x, color);
                setPixel(x0 + x, y0 - y, color);
                
                y++;
                err += 1 + 2 * y;
                if (2 * (err - x) + 1 > 0) {
                    x--;
                    err += 1 - 2 * x;
                }
            }
        }
        
        function saveHistory() {
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(JSON.parse(JSON.stringify(state.pixels)));
            state.historyIndex++;
            if (state.history.length > 50) {
                state.history.shift();
                state.historyIndex--;
            }
        }
        
        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                state.pixels = JSON.parse(JSON.stringify(state.history[state.historyIndex]));
                render();
            }
        }
        
        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                state.pixels = JSON.parse(JSON.stringify(state.history[state.historyIndex]));
                render();
            }
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', e => {
            state.isDrawing = true;
            const { x, y } = getPixelCoords(e);
            state.startX = x;
            state.startY = y;
            const color = e.button === 2 ? state.secondaryColor : state.primaryColor;
            
            switch (state.tool) {
                case 'pencil':
                    setPixel(x, y, color);
                    render();
                    break;
                case 'eraser':
                    setPixel(x, y, null);
                    render();
                    break;
                case 'fill':
                    const targetColor = state.pixels[y][x];
                    floodFill(x, y, targetColor, color);
                    saveHistory();
                    render();
                    break;
                case 'picker':
                    if (state.pixels[y][x]) {
                        state.primaryColor = state.pixels[y][x];
                        document.getElementById('primaryColor').style.background = state.primaryColor;
                        document.getElementById('colorPicker').value = state.primaryColor;
                    }
                    break;
            }
        });
        
        canvas.addEventListener('mousemove', e => {
            if (!state.isDrawing) return;
            const { x, y } = getPixelCoords(e);
            const color = e.buttons === 2 ? state.secondaryColor : state.primaryColor;
            
            if (state.tool === 'pencil') {
                setPixel(x, y, color);
                render();
            } else if (state.tool === 'eraser') {
                setPixel(x, y, null);
                render();
            }
        });
        
        canvas.addEventListener('mouseup', e => {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            const { x, y } = getPixelCoords(e);
            const color = e.button === 2 ? state.secondaryColor : state.primaryColor;
            
            switch (state.tool) {
                case 'line':
                    drawLine(state.startX, state.startY, x, y, color);
                    break;
                case 'rect':
                    drawRect(state.startX, state.startY, x, y, color);
                    break;
                case 'circle':
                    drawCircle(state.startX, state.startY, x, y, color);
                    break;
            }
            
            if (['pencil', 'eraser', 'line', 'rect', 'circle'].includes(state.tool)) {
                saveHistory();
            }
            render();
        });
        
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.tool = btn.dataset.tool;
            });
        });
        
        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.gridSize = parseInt(btn.dataset.size);
                initCanvas();
            });
        });
        
        document.getElementById('colorPicker').addEventListener('input', e => {
            state.primaryColor = e.target.value;
            document.getElementById('primaryColor').style.background = e.target.value;
        });
        
        document.getElementById('brushSize').addEventListener('input', e => {
            state.brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeLabel').textContent = e.target.value + ' ÂÉèÁ¥†';
        });
        
        document.getElementById('showGrid').addEventListener('change', e => {
            state.showGrid = e.target.checked;
            render();
        });
        
        function swapColors() {
            const temp = state.primaryColor;
            state.primaryColor = state.secondaryColor;
            state.secondaryColor = temp;
            document.getElementById('primaryColor').style.background = state.primaryColor;
            document.getElementById('secondaryColor').style.background = state.secondaryColor;
            document.getElementById('colorPicker').value = state.primaryColor;
        }
        
        function zoomIn() {
            if (state.zoom < 32) {
                state.zoom *= 2;
                document.getElementById('zoomLevel').textContent = state.zoom + 'x';
                canvas.width = state.gridSize * state.zoom;
                canvas.height = state.gridSize * state.zoom;
                render();
            }
        }
        
        function zoomOut() {
            if (state.zoom > 2) {
                state.zoom /= 2;
                document.getElementById('zoomLevel').textContent = state.zoom + 'x';
                canvas.width = state.gridSize * state.zoom;
                canvas.height = state.gridSize * state.zoom;
                render();
            }
        }
        
        function clearCanvas() {
            for (let y = 0; y < state.gridSize; y++) {
                for (let x = 0; x < state.gridSize; x++) {
                    state.pixels[y][x] = null;
                }
            }
            saveHistory();
            render();
        }
        
        function downloadImage() {
            // Create a clean export canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = state.gridSize;
            exportCanvas.height = state.gridSize;
            const exportCtx = exportCanvas.getContext('2d');
            
            for (let y = 0; y < state.gridSize; y++) {
                for (let x = 0; x < state.gridSize; x++) {
                    if (state.pixels[y][x]) {
                        exportCtx.fillStyle = state.pixels[y][x];
                        exportCtx.fillRect(x, y, 1, 1);
                    }
                }
            }
            
            const link = document.createElement('a');
            link.download = `pixel-art-${state.gridSize}x${state.gridSize}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });
        
        // Initialize
        initCanvas();
    </script>
</body>
</html>
